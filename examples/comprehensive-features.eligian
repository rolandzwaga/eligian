// Comprehensive Features Example
// This example demonstrates ALL language features currently supported by Eligian DSL

// ============================================================================
// GLOBAL VARIABLES (Phase 13)
// ============================================================================

// Program-level constants (accessed via $globaldata.varName)
const theme = "dark"
const animationDuration = 1000
const slideCount = 3

// ============================================================================
// REFERENCE SYNTAX (Phase 16.5, T229-T233)
// ============================================================================

// Three types of references in Eligian:
// 1. paramName (bare identifier) → action parameter (compiles to $operationdata.paramName)
// 2. @@varName (double-@) → system scope property (compiles to $scope.varName)
//    - Loop variables: @@item, @@element
//    - System properties: @@loopIndex, @@loopLength, @@currentIndex
// 3. @varName (single-@) → user-declared variable (compiles to $scope.variables.varName)

// ============================================================================
// PARAMETERIZED ACTIONS (Phase 14)
// ============================================================================

// Action with parameters - makes actions reusable with different inputs
endable action fadeIn(selector, duration) [
  // "selector" and "duration" are bare identifiers (parameters)
  selectElement(selector)
  setStyle({opacity: 0})
  animate({opacity: 1}, duration)
] [
  selectElement(selector)
  animate({opacity: 0}, duration)
]

// Action with parameters and local variables
action highlightElement(selector, color) [
  // LOCAL VARIABLES (Phase 13) - accessed via @varName
  const highlightDuration = 300
  const defaultColor = "yellow"

  selectElement(selector)
  setStyle({
    backgroundColor: color,
    transition: "background-color 0.3s"
  })
  wait(@highlightDuration)
]

// ============================================================================
// CONTROL FLOW (Phase 12)
// ============================================================================

// Action demonstrating if/else statements
action conditionalHighlight(selector, shouldHighlight) [
  selectElement(selector)

  // IF/ELSE - compiles to when/otherwise/endWhen
  if (shouldHighlight) {
    addClass("highlight")
    setStyle({border: "2px solid yellow"})
  } else {
    removeClass("highlight")
    setStyle({border: "none"})
  }
]

// Action demonstrating for loops
action animateItems(items) [
  // FOR LOOP - compiles to forEach/endForEach
  for (item in items) {
    selectElement(@@item)
    addClass("animated")
    wait(200)
  }
]

// Nested control flow example
action complexAnimation(elements, duration) [
  const delayStep = 100
  const isVisible = true

  for (element in elements) {
    selectElement(@@element)

    // Nested if/else inside loop
    if (@isVisible) {
      animate({opacity: 1}, duration)
    } else {
      setStyle({opacity: 0})
    }

    wait(@delayStep)
  }
]

// ============================================================================
// EXPRESSIONS AND OPERATIONS
// ============================================================================

// Action demonstrating various expression types
action expressionExamples() [
  // BINARY EXPRESSIONS - Math
  const calculatedDuration = 500
  const doubleDuration = 1000

  // BINARY EXPRESSIONS - Comparison
  if (1000 > 500) {
    //log("Duration is sufficient")
  }

  // BINARY EXPRESSIONS - Logical operators
  const enabled = true  // Local variable for demonstration
  selectElement(".demo")
  if ($globaldata.theme == "dark" && @enabled) {
    addClass("dark-mode-enabled")
  }

  // ARRAY LITERALS
  const colorOptions = ["red", "blue", "green"]

  // OBJECT LITERALS with nested properties
  const animationConfig = {
    duration: @calculatedDuration,
    easing: "ease-in-out",
    properties: {
      opacity: 1,
      transform: "scale(1)"
    }
  }

  // PROPERTY CHAIN REFERENCES (using existing selected element)
  setStyle({
    color: $globaldata.theme,
    animationDuration: @calculatedDuration
  })
]

// ============================================================================
// TIMELINE WITH ALL FEATURES
// ============================================================================

timeline "comprehensive-demo" using raf {
  // PARAMETERIZED ACTION INVOCATION
  at 0s..3s {
    fadeIn(".title", 1000)
  }

  // RELATIVE TIME EXPRESSIONS (Phase 15, T189)
  // +0s means: start at previous event's end time (3s)
  // +2s means: duration of 2 seconds from that point
  at +0s..+2s {
    highlightElement(".subtitle", "yellow")
  }

  // INLINE ENDABLE ACTION with control flow
  at 3s..8s [
    selectElement(".content")
    addClass("visible")

    // FOR LOOP in timeline event
    for (section in ["intro", "main", "outro"]) {
      selectElement(@@section)
      addClass("active")
      wait(500)
    }
  ] [
    selectElement(".content")
    removeClass("visible")
  ]

  // INLINE ACTION with conditional logic
  at 5s..10s [
    selectElement(".panel")

    if ($globaldata.theme == "dark") {
      addClass("dark-panel")
      setStyle({backgroundColor: "#333", color: "#fff"})
    } else {
      addClass("light-panel")
      setStyle({backgroundColor: "#fff", color: "#333"})
    }
  ] [
    selectElement(".panel")
    removeClass("dark-panel")
    removeClass("light-panel")
  ]

  // COMPLEX EXPRESSIONS in arguments
  at 8s..12s {
    fadeIn(".footer", 500)
  }

  // More RELATIVE TIME examples showing sequential animations
  // After previous event ends at 12s:
  at +1s..+3s [  // 13s..15s (1s pause, then 2s duration)
    selectElement(".note")
    addClass("pulse")
  ] [
    selectElement(".note")
    removeClass("pulse")
  ]

  at +0s..+4s {  // 15s..19s (continues immediately, 4s duration)
    fadeIn(".credits", 800)
  }
}

// ============================================================================
// STAGGER SYNTAX (Phase 16, T192)
// ============================================================================

// Stagger blocks provide automatic timing for animations that should
// start with incremental delays (common for list animations)

timeline "stagger-demo" using raf {
  // STAGGER BLOCK with action call - automatically passes each item to the action
  // Each item starts 200ms after the previous one
  stagger 200ms [".card-1", ".card-2", ".card-3"] with fadeIn() for 2s
  // Expands to:
  //   at 0s..2s { fadeIn(".card-1") }
  //   at 0.2s..2.2s { fadeIn(".card-2") }
  //   at 0.4s..2.4s { fadeIn(".card-3") }

  // STAGGER BLOCK with inline operations - more control over each item's animation
  stagger 100ms [".box-1", ".box-2", ".box-3", ".box-4"] for 1s [
    selectElement(@@item)
    addClass("pulse")
    animate({scale: 1.1}, 500)
  ] [
    selectElement(@@item)
    removeClass("pulse")
    animate({scale: 1}, 500)
  ]
  // Each box pulses in sequence with 100ms delay between each

  // Combine stagger with sequence for complex animations
  sequence {
    fadeIn(".header", 500) for 2s

    // After header (2s), stagger the navigation items
    // Note: stagger uses previousEventEndTime, so this starts at 2s
  }

  stagger 150ms [".nav-1", ".nav-2", ".nav-3"] with fadeIn() for 1s
  // Starts at 2s: 2s..3s, 2.15s..3.15s, 2.3s..3.3s
}

// ============================================================================
// SEQUENCE SYNTAX (Phase 15, T190)
// ============================================================================

// Sequence blocks provide a declarative way to define sequential events
// without calculating time ranges manually

timeline "sequence-demo" using raf {
  // SEQUENCE BLOCK - automatic time calculation
  // Each action runs for the specified duration, one after another
  sequence {
    fadeIn(".title", 1000) for 3s     // 0-3s: fade in title over 3 seconds
    fadeIn(".subtitle", 500) for 2s   // 3-5s: fade in subtitle over 2 seconds
    fadeIn(".content", 800) for 5s    // 5-10s: fade in content over 5 seconds
  }

  // Mix sequence blocks with regular timed events
  at 12s..15s {
    fadeIn(".footer", 500)  // Regular timed event at 12-15s
  }

  // Another sequence block continues from where timeline left off (15s)
  sequence {
    highlightElement(".note", "yellow") for 2s   // 0-2s (starts at 0 in new sequence)
    highlightElement(".warning", "red") for 2s   // 2-4s
  }
}
