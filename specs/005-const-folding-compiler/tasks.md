# Implementation Tasks: Constant Folding Optimization

**Branch**: `005-const-folding-compiler` | **Date**: 2025-01-23 | **Spec**: [spec.md](./spec.md)

Generated by `/speckit.tasks` command. See [quickstart.md](./quickstart.md) for detailed implementation guide.

---

## Overview

This document breaks down the constant folding optimization implementation into ordered, testable tasks. The project follows Test-First Development (TDD) as required by the constitution - all test tasks must be completed before corresponding implementation tasks.

**User Stories**:
- **[US1]** P1: Inline constant values in generated JSON (core functionality)
- **[US2]** P2: Eliminate init actions for constants-only files
- **[US3]** P3: Compile-time expression evaluation (arithmetic, string concat, logical ops)

**Parallel Execution**: Tasks marked with **[P]** can be executed in parallel with other [P] tasks in the same phase.

---

## Phase 0: Setup and Investigation

### T001 [P] - Review existing AST structure
**Priority**: Foundational | **Time**: 30m | **Blocking**: T004, T007

**Description**: Understand the existing Langium AST structure for `ConstDeclaration` and `VariableReference` nodes.

**Actions**:
- Read [packages/language/src/generated/ast.ts](../../packages/language/src/generated/ast.ts) to understand `ConstDeclaration` node structure
- Read [packages/language/src/eligian.langium](../../packages/language/src/eligian.langium) to verify const/let grammar rules
- Document AST node types: `ConstDeclaration`, `VariableReference`, `Literal`, `BinaryExpression`, `UnaryExpression`
- Identify which fields contain constant name, value expression, and source location

**Acceptance**:
- [X] Can describe `ConstDeclaration` node structure (name, value, $type)
- [X] Can describe `VariableReference` node structure (name, $type)
- [X] Understand how to access source location from `$cstNode` property

---

### T002 [P] - Review existing compiler pipeline
**Priority**: Foundational | **Time**: 30m | **Blocking**: T007, T014

**Description**: Understand the existing compilation pipeline and identify integration points for constant folding.

**Actions**:
- Read [packages/language/src/compiler/ast-transformer.ts](../../packages/language/src/compiler/ast-transformer.ts) to understand transformation flow
- Read [packages/language/src/compiler/optimizer.ts](../../packages/language/src/compiler/optimizer.ts) to understand existing optimization passes
- Document current init action generation logic (where globalData assignments are created)
- Identify where variable references are currently transformed to `$globalData.<name>` patterns

**Acceptance**:
- [X] Can describe the transformation pipeline order (parse → validate → transform → optimize → emit)
- [X] Located the method that generates init actions
- [X] Located the method that transforms variable references to globalData lookups

---

### T003 [P] - Create type definitions file
**Priority**: Foundational | **Time**: 15m | **Blocking**: T004, T009, T018

**Description**: Create types.ts with data structures defined in data-model.md.

**File**: [packages/language/src/compiler/types.ts](../../packages/language/src/compiler/types.ts) (NEW)

**Actions**:
- Create `ConstantValue` interface with fields: name, value, type, sourceLocation (optional)
- Create `ConstantMap` type alias: `Map<string, ConstantValue>`
- Create `ExpressionEvaluationResult` interface with fields: canEvaluate, value (optional), error (optional)
- Add JSDoc comments explaining usage of each type
- Export all types for use in other modules

**Acceptance**:
- [X] File created with all three types defined
- [X] Types match data-model.md specification exactly
- [X] JSDoc comments explain when/how each type is used
- [X] File compiles with no TypeScript errors

---

## Phase 1: User Story 1 (P1) - Inline Constant Values

*Goal: Replace constant references with literal values in generated JSON*

### T004 - Write tests for buildConstantMap (string constants)
**Priority**: P1 | **Time**: 30m | **Blocking**: T005 | **Depends**: T001, T003 | **Labels**: [US1], TDD

**Description**: Write failing tests for detecting string constants before implementing buildConstantMap.

**File**: [packages/language/src/compiler/__tests__/constant-folder.spec.ts](../../packages/language/src/compiler/__tests__/constant-folder.spec.ts) (NEW)

**Actions**:
- Create test file with describe block for `buildConstantMap`
- Write test: "should detect string constant" - parse `const MESSAGE = "hello";` and verify map contains correct ConstantValue
- Write test: "should handle multiple string constants" - verify map size and contents
- Write test: "should preserve type information for strings" - verify type field is 'string'
- Import helper functions for parsing Eligian code (from existing test utilities)
- Run tests and verify they FAIL (function doesn't exist yet)

**Acceptance**:
- [X] Test file created with 3+ test cases for string constants
- [X] Tests use proper Vitest syntax (describe, it, expect)
- [X] Tests verify ConstantValue structure (name, value, type)
- [X] Tests FAIL with clear error message (function not found)

---

### T005 - Write tests for buildConstantMap (number and boolean constants)
**Priority**: P1 | **Time**: 20m | **Blocking**: T006 | **Depends**: T004 | **Labels**: [US1], TDD

**Description**: Extend tests to cover number and boolean primitive types.

**File**: [packages/language/src/compiler/__tests__/constant-folder.spec.ts](../../packages/language/src/compiler/__tests__/constant-folder.spec.ts) (MODIFY)

**Actions**:
- Add test: "should detect number constant" - parse `const DELAY = 1000;` and verify type is 'number'
- Add test: "should detect boolean constant (true)" - verify value is boolean true
- Add test: "should detect boolean constant (false)" - verify value is boolean false
- Add test: "should ignore let variables" - parse mixed const/let, verify only const in map
- Run tests and verify all FAIL

**Acceptance**:
- [X] Added 4+ new test cases covering number and boolean types
- [X] Test for ignoring `let` variables included (NOTE: Grammar only supports `const`, not `let` yet)
- [X] Tests verify type preservation (string vs number vs boolean)
- [X] All tests FAIL (buildConstantMap not implemented)

---

### T006 - Implement buildConstantMap function
**Priority**: P1 | **Time**: 45m | **Blocking**: T008 | **Depends**: T005 | **Labels**: [US1]

**Description**: Implement constant map building logic to detect and evaluate literal constants.

**File**: [packages/language/src/compiler/constant-folder.ts](../../packages/language/src/compiler/constant-folder.ts) (NEW)

**Actions**:
- Create constant-folder.ts file with export of `buildConstantMap` function
- Implement function signature: `(program: Program) => ConstantMap`
- Traverse `program.elements` to find `ConstDeclaration` nodes (filter by `$type === 'ConstDeclaration'`)
- For each const declaration with literal value, extract name, value, and type
- Store in Map with ConstantValue structure
- Extract source location from `$cstNode.range` for error reporting
- Ignore non-literal values (expressions) - these are handled in US3 (P3)

**Acceptance**:
- [ ] File created with buildConstantMap function
- [ ] Function correctly traverses AST and finds ConstDeclaration nodes
- [ ] Only processes declarations with literal values (not expressions yet)
- [ ] Correctly determines type ('string' | 'number' | 'boolean') using typeof
- [ ] Stores source location from AST node
- [ ] All tests from T004 and T005 now PASS
- [ ] Run `pnpm run test constant-folder.spec.ts` → all tests pass

---

### T007 - Write tests for constant reference inlining in transformer
**Priority**: P1 | **Time**: 45m | **Blocking**: T008 | **Depends**: T002, T006 | **Labels**: [US1], TDD

**Description**: Write failing tests for the transformer to verify constant values are inlined instead of $globalData references.

**File**: [packages/language/src/compiler/__tests__/transformer.spec.ts](../../packages/language/src/compiler/__tests__/transformer.spec.ts) (MODIFY)

**Actions**:
- Add describe block: "constant folding - reference inlining"
- Write test: "should inline string constant" - compile source with const + action, verify JSON contains literal "hello" and no $globalData.MESSAGE
- Write test: "should inline number constant" - verify JSON contains number 1000, not $globalData reference
- Write test: "should inline boolean constant" - verify JSON contains boolean true/false
- Write test: "should inline multiple references to same constant" - verify consistent inlining
- Run tests and verify they FAIL (constants still generate $globalData references)

**Acceptance**:
- [ ] Added 4+ test cases to transformer.spec.ts
- [ ] Tests compile full Eligian source and check generated JSON
- [ ] Tests use `JSON.stringify(json).toContain()` for verification
- [ ] Tests check both presence of literal AND absence of $globalData pattern
- [ ] All tests FAIL (constant inlining not implemented yet)

---

### T008 - Integrate buildConstantMap into ast-transformer
**Priority**: P1 | **Time**: 30m | **Blocking**: T009 | **Depends**: T006, T007 | **Labels**: [US1]

**Description**: Modify ast-transformer to build constant map before transformation and use it during variable reference transformation.

**File**: [packages/language/src/compiler/ast-transformer.ts](../../packages/language/src/compiler/ast-transformer.ts) (MODIFY)

**Actions**:
- Import `buildConstantMap` from constant-folder.ts
- Import `ConstantMap` type from types.ts
- Add private field to AstTransformer class: `private constantMap: ConstantMap = new Map()`
- In `transform(program: Program)` method, call `this.constantMap = buildConstantMap(program)` BEFORE transformation
- Locate existing `transformVariableReference` method
- Modify method to check if reference name exists in constantMap
- If found: return literal value (constant.value) instead of $globalData reference
- If not found: return existing $globalData reference behavior

**Acceptance**:
- [ ] ast-transformer.ts imports buildConstantMap function
- [ ] constantMap field added and populated before transformation
- [ ] transformVariableReference checks constantMap before generating $globalData
- [ ] Returns literal value for constant references
- [ ] Returns $globalData reference for non-constant variables
- [ ] All tests from T007 now PASS
- [ ] Run `pnpm run test transformer.spec.ts` → constant folding tests pass

---

### T009 - Write tests for type preservation during inlining
**Priority**: P1 | **Time**: 20m | **Blocking**: T010 | **Depends**: T008 | **Labels**: [US1], TDD

**Description**: Write tests to verify that string "5" is not confused with number 5 during constant inlining.

**File**: [packages/language/src/compiler/__tests__/transformer.spec.ts](../../packages/language/src/compiler/__tests__/transformer.spec.ts) (MODIFY)

**Actions**:
- Add test: "should preserve string type for numeric-looking strings" - const VALUE = "5", verify JSON contains string "5"
- Add test: "should preserve number type" - const VALUE = 5, verify JSON contains number 5 (not "5")
- Add test: "should distinguish true from 'true'" - test both boolean and string
- Verify JSON output uses correct JSON types (string in quotes, number unquoted, boolean as true/false)
- Run tests and verify behavior (may pass or fail depending on current implementation)

**Acceptance**:
- [ ] Added 3+ test cases verifying type preservation
- [ ] Tests check JSON serialization format (quotes for strings, no quotes for numbers/booleans)
- [ ] Tests cover edge cases (string "5" vs number 5, string "true" vs boolean true)
- [ ] All tests PASS (type preservation should work with ConstantValue.type field)

---

### T010 - Add integration test for User Story 1
**Priority**: P1 | **Time**: 30m | **Blocking**: None | **Depends**: T009 | **Labels**: [US1], TDD

**Description**: Create end-to-end integration test that validates US1 acceptance criteria.

**File**: [packages/language/src/__tests__/integration/constant-folding.spec.ts](../../packages/language/src/__tests__/integration/constant-folding.spec.ts) (NEW)

**Actions**:
- Create new integration test file
- Write test matching US1 Acceptance Scenario 1: `const MESSAGE = "hello"` used in action, verify literal "hello" in JSON
- Write test matching US1 Acceptance Scenario 2: `const DELAY = 1000` used in multiple actions, verify all references are 1000
- Write test matching US1 Acceptance Scenario 3: `const FLAG = true` used in conditional, verify boolean true
- Verify no $globalData references for any constants
- Run full compilation pipeline for each test

**Acceptance**:
- [ ] Integration test file created with 3+ test cases
- [ ] Tests match user story acceptance scenarios exactly
- [ ] Tests compile full Eligian programs and validate JSON structure
- [ ] All tests PASS
- [ ] Run `pnpm run test integration/constant-folding.spec.ts` → all pass

---

## Phase 2: User Story 2 (P2) - Eliminate Init Actions

*Goal: Don't generate init actions when only constants exist*

### T011 - Write tests for init action elimination (constants only)
**Priority**: P2 | **Time**: 20m | **Blocking**: T012 | **Depends**: T010 | **Labels**: [US2], TDD

**Description**: Write failing tests to verify init actions are not generated for files with only constants.

**File**: [packages/language/src/compiler/__tests__/transformer.spec.ts](../../packages/language/src/compiler/__tests__/transformer.spec.ts) (MODIFY)

**Actions**:
- Add describe block: "init action elimination"
- Write test: "should not generate init action for constants only" - source with 2+ const declarations, verify `json.init === undefined`
- Write test: "should not generate init action for empty file" - no declarations, verify no init
- Write test: "should still generate init for let variables" - source with only let declarations, verify init exists
- Run tests and check results (init may still be generated for constants)

**Acceptance**:
- [ ] Added 3+ test cases for init action behavior
- [ ] Tests verify init action presence/absence using `expect(json.init).toBeUndefined()` or `.toBeDefined()`
- [ ] Tests cover edge cases (empty file, only const, only let)
- [ ] Tests may FAIL if init is currently generated for constants

---

### T012 - Write tests for init action with mixed const/let
**Priority**: P2 | **Time**: 20m | **Blocking**: T013 | **Depends**: T011 | **Labels**: [US2], TDD

**Description**: Write tests to verify init actions only contain let variables, not const declarations.

**File**: [packages/language/src/compiler/__tests__/transformer.spec.ts](../../packages/language/src/compiler/__tests__/transformer.spec.ts) (MODIFY)

**Actions**:
- Add test: "should only include let variables in init action" - source with `const A = 5; let B = 10;`, verify init exists
- Verify init action contains assignment for B but not A
- Add test: "should handle multiple let variables with constants" - 2+ const, 2+ let, verify init only has let variables
- Check JSON structure: `json.init.operations` should only contain setGlobalData for let variables
- Run tests and verify expected failures

**Acceptance**:
- [ ] Added 2+ test cases for mixed const/let scenarios
- [ ] Tests verify init action exists but only contains let variable assignments
- [ ] Tests check JSON structure: `JSON.stringify(json.init).toContain('"B"')` but not contain '"A"'
- [ ] Tests FAIL if constants currently appear in init action

---

### T013 - Modify init action generation to exclude constants
**Priority**: P2 | **Time**: 30m | **Blocking**: T014 | **Depends**: T012 | **Labels**: [US2]

**Description**: Update the init action generation logic to skip const declarations and only include let variables.

**File**: [packages/language/src/compiler/ast-transformer.ts](../../packages/language/src/compiler/ast-transformer.ts) (MODIFY)

**Actions**:
- Locate the method that generates init actions (likely `generateInitAction` or similar)
- Modify the logic to filter out elements where `$type === 'ConstDeclaration'`
- Only generate globalData assignments for `VariableDeclaration` with `kind === 'let'`
- If no let variables exist, return `undefined` instead of empty init action
- Update return type to allow undefined: `InitAction | undefined`

**Acceptance**:
- [ ] Init action generation filters out const declarations
- [ ] Only let variables generate globalData assignments
- [ ] Returns undefined when no let variables exist
- [ ] All tests from T011 and T012 now PASS
- [ ] Run `pnpm run test transformer.spec.ts` → init elimination tests pass

---

### T014 - Add integration test for User Story 2
**Priority**: P2 | **Time**: 20m | **Blocking**: None | **Depends**: T013 | **Labels**: [US2], TDD

**Description**: Create end-to-end integration test that validates US2 acceptance criteria.

**File**: [packages/language/src/__tests__/integration/constant-folding.spec.ts](../../packages/language/src/__tests__/integration/constant-folding.spec.ts) (MODIFY)

**Actions**:
- Add test matching US2 Acceptance Scenario 1: file with only const declarations, verify no init action
- Add test matching US2 Acceptance Scenario 2: mixed const/let, verify init only has let assignments
- Verify JSON structure matches expected output (no init for constants-only files)
- Run full compilation pipeline

**Acceptance**:
- [ ] Integration test added with 2+ test cases
- [ ] Tests match US2 acceptance scenarios exactly
- [ ] All tests PASS
- [ ] Run `pnpm run test integration/constant-folding.spec.ts` → all pass

---

## Phase 3: User Story 3 (P3) - Compile-Time Expression Evaluation

*Goal: Evaluate simple expressions at compile time (e.g., const SUM = 10 + 20 → inline 30)*

### T015 [P] - Write tests for evaluateExpression (arithmetic)
**Priority**: P3 | **Time**: 30m | **Blocking**: T017 | **Depends**: T003 | **Labels**: [US3], TDD

**Description**: Write failing tests for evaluating arithmetic expressions at compile time.

**File**: [packages/language/src/compiler/__tests__/expression-evaluator.spec.ts](../../packages/language/src/compiler/__tests__/expression-evaluator.spec.ts) (NEW)

**Actions**:
- Create test file with describe block for `evaluateExpression`
- Write test: "should evaluate addition (10 + 20)" - verify result is 30
- Write test: "should evaluate subtraction (50 - 30)" - verify result is 20
- Write test: "should evaluate multiplication (5 * 6)" - verify result is 30
- Write test: "should evaluate division (20 / 4)" - verify result is 5
- Write test: "should detect division by zero (10 / 0)" - verify error returned
- Use helper to parse binary expressions from Eligian source
- Run tests and verify they FAIL (function doesn't exist)

**Acceptance**:
- [ ] Test file created with 5+ test cases for arithmetic operations
- [ ] Tests verify ExpressionEvaluationResult structure (canEvaluate, value)
- [ ] Tests cover edge cases (division by zero)
- [ ] All tests FAIL (evaluateExpression not implemented)

---

### T016 [P] - Write tests for evaluateExpression (string concat, logical ops)
**Priority**: P3 | **Time**: 30m | **Blocking**: T017 | **Depends**: T003 | **Labels**: [US3], TDD

**Description**: Write tests for string concatenation and logical operations.

**File**: [packages/language/src/compiler/__tests__/expression-evaluator.spec.ts](../../packages/language/src/compiler/__tests__/expression-evaluator.spec.ts) (MODIFY)

**Actions**:
- Add test: "should evaluate string concatenation ('Hello' + ' World')" - verify result is "Hello World"
- Add test: "should evaluate logical AND (true && false)" - verify result is false
- Add test: "should evaluate logical OR (false || true)" - verify result is true
- Add test: "should evaluate logical NOT (!true)" - verify result is false
- Add test: "should evaluate comparison (5 > 3)" - verify result is true
- Run tests and verify all FAIL

**Acceptance**:
- [ ] Added 5+ test cases covering string and logical operations
- [ ] Tests verify correct evaluation of expressions
- [ ] All tests FAIL (evaluateExpression not implemented)

---

### T017 - Implement evaluateExpression function
**Priority**: P3 | **Time**: 60m | **Blocking**: T018 | **Depends**: T015, T016 | **Labels**: [US3]

**Description**: Implement compile-time expression evaluator for simple expressions.

**File**: [packages/language/src/compiler/expression-evaluator.ts](../../packages/language/src/compiler/expression-evaluator.ts) (NEW)

**Actions**:
- Create expression-evaluator.ts with export of `evaluateExpression` function
- Implement function signature: `(expr: Expression, constants: ConstantMap, evaluating?: Set<string>) => ExpressionEvaluationResult`
- Implement switch statement on `expr.$type` to handle: Literal, BinaryExpression, UnaryExpression, VariableReference
- For Literal: return value directly (already constant)
- For BinaryExpression: recursively evaluate left/right, apply operator (+, -, *, /, %, &&, ||, ==, etc.)
- For UnaryExpression: recursively evaluate operand, apply operator (!, -, +)
- For VariableReference: check if in constantMap, return value (support transitive constants)
- Implement `applyBinaryOperator` helper function for all operators
- Implement `applyUnaryOperator` helper function
- Wrap in try/catch and return ExpressionEvaluationResult with error on failure

**Acceptance**:
- [ ] File created with evaluateExpression function
- [ ] Handles all required expression types (Literal, Binary, Unary, Reference)
- [ ] Implements all arithmetic operators (+, -, *, /, %)
- [ ] Implements string concatenation (+)
- [ ] Implements logical operators (&&, ||, !)
- [ ] Implements comparison operators (==, !=, <, >, <=, >=)
- [ ] Returns success result with value on successful evaluation
- [ ] Returns error result with reason on failure
- [ ] All tests from T015 and T016 now PASS
- [ ] Run `pnpm run test expression-evaluator.spec.ts` → all tests pass

---

### T018 - Write tests for transitive constant resolution
**Priority**: P3 | **Time**: 30m | **Blocking**: T019 | **Depends**: T017, T003 | **Labels**: [US3], TDD

**Description**: Write tests to verify that constants can reference other constants (transitive dependencies).

**File**: [packages/language/src/compiler/__tests__/expression-evaluator.spec.ts](../../packages/language/src/compiler/__tests__/expression-evaluator.spec.ts) (MODIFY)

**Actions**:
- Add test: "should resolve constant reference" - constantMap has A=5, expression is A+3, verify result is 8
- Add test: "should resolve transitive constant" - A=5, B=A+3, expression references B, verify result is 8
- Add test: "should detect circular dependency" - A=B, B=A, verify error returned
- Add test: "should error on undefined constant reference" - expression references X (not in map), verify error
- Mock ConstantMap with pre-populated values for testing
- Run tests and check results (may pass or fail depending on current implementation)

**Acceptance**:
- [ ] Added 4+ test cases for constant reference resolution
- [ ] Tests verify transitive resolution works (const referencing const)
- [ ] Tests verify circular dependency detection
- [ ] Tests verify error handling for undefined constants
- [ ] All tests PASS (or FAIL if circular detection not yet implemented)

---

### T019 - Add circular dependency detection
**Priority**: P3 | **Time**: 30m | **Blocking**: T020 | **Depends**: T018 | **Labels**: [US3]

**Description**: Implement cycle detection using the evaluating Set parameter to prevent infinite loops.

**File**: [packages/language/src/compiler/expression-evaluator.ts](../../packages/language/src/compiler/expression-evaluator.ts) (MODIFY)

**Actions**:
- In evaluateExpression, add optional parameter `evaluating: Set<string> = new Set()`
- When evaluating VariableReference, check if `evaluating.has(ref.name)`
- If true, throw error with message: `Circular dependency detected: ${ref.name}`
- If false, add `ref.name` to evaluating set before recursive evaluation
- Pass evaluating set to recursive calls
- Add test case: `const A = B + 1; const B = A + 1;` → should throw circular dependency error

**Acceptance**:
- [ ] evaluating Set parameter added to function signature
- [ ] Circular dependency check added before resolving variable reference
- [ ] Error thrown with clear message when cycle detected
- [ ] All tests from T018 now PASS
- [ ] Run `pnpm run test expression-evaluator.spec.ts` → circular dependency tests pass

---

### T020 - Integrate expression evaluator into buildConstantMap
**Priority**: P3 | **Time**: 30m | **Blocking**: T021 | **Depends**: T019 | **Labels**: [US3]

**Description**: Modify buildConstantMap to use expression evaluator instead of only handling literals.

**File**: [packages/language/src/compiler/constant-folder.ts](../../packages/language/src/compiler/constant-folder.ts) (MODIFY)

**Actions**:
- Import `evaluateExpression` from expression-evaluator.ts
- Remove literal-only restriction from buildConstantMap
- For each ConstDeclaration, call `evaluateExpression(constDecl.value, map)`
- If `result.canEvaluate === true`, add to map with result.value
- If `result.canEvaluate === false`, log warning and skip (treat as regular variable, no folding)
- Warning message should include constant name and error reason
- Pass constant map to evaluateExpression for transitive resolution

**Acceptance**:
- [ ] constant-folder.ts imports evaluateExpression
- [ ] buildConstantMap calls evaluateExpression for all const values (not just literals)
- [ ] Adds successfully evaluated expressions to constant map
- [ ] Logs warning for unevaluable expressions (does not throw)
- [ ] Supports transitive constants (A=5, B=A+3)
- [ ] Run `pnpm run test constant-folder.spec.ts` → may need new tests

---

### T021 - Write tests for expression-based constants in transformer
**Priority**: P3 | **Time**: 30m | **Blocking**: T022 | **Depends**: T020 | **Labels**: [US3], TDD

**Description**: Write tests to verify that expression-based constants are inlined with computed values.

**File**: [packages/language/src/compiler/__tests__/transformer.spec.ts](../../packages/language/src/compiler/__tests__/transformer.spec.ts) (MODIFY)

**Actions**:
- Add describe block: "constant folding - expression evaluation"
- Write test: "should inline arithmetic expression result" - `const SUM = 10 + 20;`, verify JSON contains 30
- Write test: "should inline string concatenation result" - `const NAME = "Hello" + " World";`, verify JSON contains "Hello World"
- Write test: "should inline logical expression result" - `const FLAG = true && false;`, verify JSON contains false
- Write test: "should inline transitive constant" - `const A = 5; const B = A + 3;`, verify B references inline as 8
- Run tests and verify they PASS (expression evaluator integrated)

**Acceptance**:
- [ ] Added 4+ test cases for expression-based constants
- [ ] Tests verify computed values are inlined (not expressions)
- [ ] Tests cover arithmetic, string concat, logical, and transitive cases
- [ ] All tests PASS
- [ ] Run `pnpm run test transformer.spec.ts` → expression tests pass

---

### T022 - Add integration test for User Story 3
**Priority**: P3 | **Time**: 30m | **Blocking**: None | **Depends**: T021 | **Labels**: [US3], TDD

**Description**: Create end-to-end integration test that validates US3 acceptance criteria.

**File**: [packages/language/src/__tests__/integration/constant-folding.spec.ts](../../packages/language/src/__tests__/integration/constant-folding.spec.ts) (MODIFY)

**Actions**:
- Add test matching US3 Acceptance Scenario 1: `const SUM = 10 + 20;`, verify JSON contains 30
- Add test matching US3 Acceptance Scenario 2: `const NAME = "Hello" + " World";`, verify JSON contains "Hello World"
- Add test matching US3 Acceptance Scenario 3: `const ENABLED = true && false;`, verify JSON contains false
- Verify no $globalData references or expression structures in JSON
- Run full compilation pipeline

**Acceptance**:
- [ ] Integration test added with 3+ test cases
- [ ] Tests match US3 acceptance scenarios exactly
- [ ] All tests PASS
- [ ] Run `pnpm run test integration/constant-folding.spec.ts` → all pass

---

## Phase 4: Comprehensive Integration and Polish

### T023 - Create comprehensive integration test
**Priority**: High | **Time**: 30m | **Blocking**: T024 | **Depends**: T022 | **Labels**: [US1], [US2], [US3], TDD

**Description**: Create a comprehensive test that validates all three user stories together in a realistic scenario.

**File**: [packages/language/src/__tests__/integration/constant-folding.spec.ts](../../packages/language/src/__tests__/integration/constant-folding.spec.ts) (MODIFY)

**Actions**:
- Add test: "should handle real-world example with all features" - create source with:
  - Multiple string, number, boolean constants
  - Expression-based constants (arithmetic, string concat)
  - Transitive constants (A=5, B=A+3)
  - Actions that reference constants
  - Mixed const/let declarations
- Verify JSON output:
  - All constants inlined with correct values
  - No $globalData references for constants
  - Init action only contains let variables (or absent if no let)
  - Expressions evaluated to literals
- Compare JSON size before/after optimization (measure FR-001 20% reduction)

**Acceptance**:
- [ ] Comprehensive test created covering all user stories
- [ ] Test uses realistic Eligian program structure
- [ ] Verifies all constant folding features work together
- [ ] Test PASSES
- [ ] Run `pnpm run test integration/constant-folding.spec.ts` → comprehensive test passes

---

### T024 - Run full regression test suite
**Priority**: Critical | **Time**: 15m | **Blocking**: T025 | **Depends**: T023 | **Labels**: Testing

**Description**: Run all existing tests to ensure constant folding doesn't break existing functionality.

**Actions**:
- Run `pnpm run test` to execute all tests in packages/language
- Verify all tests pass (no regressions introduced)
- If failures occur, investigate and fix (may be expected JSON format changes)
- Document any intentional changes to test expectations (e.g., constants now inlined)

**Acceptance**:
- [ ] All existing tests still pass (or failures are understood and fixed)
- [ ] No regressions in parsing, validation, or other compiler features
- [ ] Constant folding is transparent to unrelated functionality
- [ ] Success Criterion SC-004 validated (backward compatibility)

---

### T025 - Measure and validate performance metrics
**Priority**: High | **Time**: 30m | **Blocking**: T026 | **Depends**: T024 | **Labels**: Performance

**Description**: Benchmark compilation time and JSON size to validate success criteria SC-001 and SC-003.

**Actions**:
- Create benchmark script or use existing test files with many constants
- Measure compilation time before optimization (disable constant folding temporarily)
- Measure compilation time after optimization (enable constant folding)
- Calculate percentage increase - must be <10% (SC-003)
- Measure generated JSON size for typical files (before/after)
- Calculate percentage reduction - should be 20%+ (SC-001)
- Document results in spec.md or create PERFORMANCE.md file

**Acceptance**:
- [ ] Compilation time increase is <10% (SC-003)
- [ ] JSON size reduced by 20%+ for files with constants (SC-001)
- [ ] Performance metrics documented
- [ ] If metrics don't meet criteria, optimize critical path (map lookups, lazy evaluation)

---

### T026 [P] - Add error handling tests (edge cases)
**Priority**: Medium | **Time**: 30m | **Blocking**: None | **Depends**: T025 | **Labels**: [US3], TDD

**Description**: Write tests for edge cases and error conditions in constant folding.

**File**: [packages/language/src/compiler/__tests__/expression-evaluator.spec.ts](../../packages/language/src/compiler/__tests__/expression-evaluator.spec.ts) (MODIFY)

**Actions**:
- Add test: "should error on type mismatch ('hello' + 5)" - verify error result (string + number invalid)
- Add test: "should error on undefined constant reference" - expression uses unknown constant, verify error
- Add test: "should handle division by zero" - verify error result with helpful message
- Add test: "should handle nested expressions" - (5 + 3) * 2, verify result is 16
- Add test: "should gracefully fail on unsupported expression types" - function calls, ternary, etc.
- Verify error messages include source location and helpful hints

**Acceptance**:
- [ ] Added 5+ test cases for error handling and edge cases
- [ ] Tests verify ExpressionEvaluationResult.error structure
- [ ] Error messages include reason, expression, and source location
- [ ] All tests PASS
- [ ] Graceful fallback: unevaluable constants treated as variables (no folding, no crash)

---

### T027 [P] - Update documentation and examples
**Priority**: Medium | **Time**: 30m | **Blocking**: None | **Depends**: T025 | **Labels**: Documentation

**Description**: Update project documentation to reflect constant folding optimization.

**Files**:
- [CLAUDE.md](../../CLAUDE.md) (MODIFY)
- [packages/language/README.md](../../packages/language/README.md) (MODIFY)
- [examples/](../../examples/) (ADD new example)

**Actions**:
- Update CLAUDE.md to mention constant folding in compiler architecture section
- Add section to language package README explaining constant folding optimization
- Create example file: `examples/constant-folding-demo.eligian` demonstrating feature
- Document that optimization is always-on and transparent
- Explain supported expression types and limitations
- Mention performance benefits (20%+ JSON size reduction)

**Acceptance**:
- [ ] CLAUDE.md updated with constant folding context
- [ ] Package README updated with optimization description
- [ ] Example file created with comprehensive demonstrations
- [ ] Documentation explains benefits, limitations, and behavior

---

### T028 [P] - Code quality check with Biome
**Priority**: Required | **Time**: 10m | **Blocking**: T029 | **Depends**: T026, T027 | **Labels**: Code Quality

**Description**: Run Biome formatter and linter on all new/modified files to ensure code quality.

**Actions**:
- Run `npm run check` to format and lint with auto-fix
- Review any remaining issues reported by `npm run lint`
- Fix any legitimate issues (unused imports, variables, etc.)
- Update biome.json if false positives occur (document justification)
- Verify `npm run check` produces 0 errors, 0 warnings

**Acceptance**:
- [ ] `npm run check` passes with 0 errors, 0 warnings
- [ ] All new files follow project formatting conventions
- [ ] No unused imports, variables, or dead code
- [ ] Biome configuration updated if needed (with comments explaining why)

---

### T029 - Final validation and checklist completion
**Priority**: Critical | **Time**: 30m | **Blocking**: None (Ready for PR) | **Depends**: T028 | **Labels**: Validation

**Description**: Complete final validation checklist from quickstart.md and spec.md before considering feature complete.

**Actions**:
- Go through validation checklist in [quickstart.md](./quickstart.md)
- Verify all functional requirements (FR-001 through FR-008) met
- Verify all success criteria (SC-001 through SC-005) met
- Run full test suite one final time: `pnpm run test`
- Verify all 3 user story acceptance scenarios pass
- Document any known limitations or deferred work
- Prepare feature for code review

**Validation Checklist**:
- [ ] FR-001: Compiler detects all const declarations ✅
- [ ] FR-002: All constant references replaced with literals ✅
- [ ] FR-003: No globalData assignments for constants ✅
- [ ] FR-004: Type preservation works ✅
- [ ] FR-005: Init action eliminated when only constants ✅
- [ ] FR-006: Expression evaluation works ✅ (P3)
- [ ] FR-007: Mixed const/let handled correctly ✅
- [ ] FR-008: Runtime behavior identical ✅
- [ ] SC-001: JSON size reduced by 20%+ ✅
- [ ] SC-002: 100% of constants inlined ✅
- [ ] SC-003: Compile time increase <10% ✅
- [ ] SC-004: All existing tests pass ✅
- [ ] SC-005: No init action for constants-only files ✅

**Acceptance**:
- [ ] All validation items checked and verified
- [ ] All tests pass (unit, integration, regression)
- [ ] Performance metrics meet success criteria
- [ ] Code quality checks pass (Biome)
- [ ] Documentation complete
- [ ] Ready for PR creation and code review

---

## Summary

### Phase Breakdown
- **Phase 0: Setup** (3 tasks) - Foundational work, AST review, type definitions
- **Phase 1: US1 - Inline Constants** (7 tasks) - Core constant folding, reference replacement
- **Phase 2: US2 - Eliminate Init** (4 tasks) - Remove unnecessary init actions
- **Phase 3: US3 - Expressions** (8 tasks) - Compile-time expression evaluation
- **Phase 4: Integration** (7 tasks) - Comprehensive testing, performance, polish

**Total: 29 tasks**

### Parallelization Opportunities

Tasks marked **[P]** can be executed in parallel within their phase:
- **Phase 0**: T001, T002, T003 (all parallel - foundation work)
- **Phase 3**: T015, T016 (parallel test writing for expression evaluator)
- **Phase 4**: T026, T027, T028 (parallel polish tasks)

### Dependency Graph (Critical Path)

```
T003 (types) → T004 (tests: string) → T005 (tests: number/bool) → T006 (buildConstantMap)
                                                                        ↓
T001 (AST) → T002 (pipeline) → T007 (tests: inlining) ←─────────────────┘
                                     ↓
                              T008 (integrate) → T009 (tests: types) → T010 (US1 integration)
                                                                             ↓
                              T011 (tests: init) → T012 (tests: mixed) → T013 (modify init) → T014 (US2 integration)
                                                                                                     ↓
T003 → T015 (tests: arithmetic) → T017 (evaluator) → T018 (tests: transitive) → T019 (circular detection)
T003 → T016 (tests: string/logical) ──┘                                              ↓
                                                                              T020 (integrate evaluator)
                                                                                     ↓
                                                                              T021 (tests: expressions)
                                                                                     ↓
                                                                              T022 (US3 integration)
                                                                                     ↓
                                                                              T023 (comprehensive test)
                                                                                     ↓
                                                                              T024 (regression tests)
                                                                                     ↓
                                                                              T025 (performance metrics)
                                                                                     ↓
                                                          ┌────────────────────────┼────────────────────────┐
                                                          ↓                        ↓                        ↓
                                                    T026 (edge cases)    T027 (documentation)    T028 (Biome)
                                                          └────────────────────────┼────────────────────────┘
                                                                                   ↓
                                                                              T029 (final validation)
```

### Estimated Timeline

- **Phase 0**: ~1.5 hours (parallel execution)
- **Phase 1**: ~3.5 hours (sequential with TDD)
- **Phase 2**: ~1.5 hours (sequential)
- **Phase 3**: ~4 hours (mostly sequential)
- **Phase 4**: ~2.5 hours (mostly parallel polish)

**Total: ~13 hours** (with parallel execution where possible)

### Test-First Development (TDD)

Following constitutional requirement (Principle II), all implementation tasks have corresponding test tasks:
- **16 test tasks** (T004, T005, T007, T009, T011, T012, T015, T016, T018, T021, T026 + integration tests T010, T014, T022, T023)
- **13 implementation tasks** (T006, T008, T013, T017, T019, T020, T024, T025, T027, T028, T029 + setup T001-T003)
- Tests written BEFORE implementation (tests fail first, then implementation makes them pass)

---

**Next Steps**: Begin with Phase 0 (T001, T002, T003 in parallel), then proceed through phases sequentially. Use `pnpm run test` frequently to validate progress.
