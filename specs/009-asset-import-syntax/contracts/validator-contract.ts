/**
 * Validator Contract: Asset Import Syntax
 *
 * This file defines the TypeScript interfaces and function signatures for
 * import validation. All validators follow Constitution Principle X:
 * pure functions returning typed errors, with Langium validators as thin adapters.
 *
 * Date: 2025-10-25
 * Feature: Asset Import Syntax (009)
 */

// =============================================================================
// AST Node Types (Auto-generated by Langium)
// =============================================================================

/**
 * Default import statement
 * Generated from: DefaultImport grammar rule
 */
export interface DefaultImport extends AstNode {
    $type: 'DefaultImport';
    type: 'layout' | 'styles' | 'provider';
    path: string;
}

/**
 * Named import statement
 * Generated from: NamedImport grammar rule
 */
export interface NamedImport extends AstNode {
    $type: 'NamedImport';
    name: string;
    path: string;
    assetType?: 'html' | 'css' | 'media';
}

/**
 * Union type for all import statements
 */
export type ImportStatement = DefaultImport | NamedImport;

/**
 * Asset type classification
 */
export type AssetType = 'html' | 'css' | 'media';


// =============================================================================
// Error Types
// =============================================================================

/**
 * Base error interface for all import validation errors
 */
export interface ImportValidationError {
    code: string;
    message: string;
    hint: string;
}

/**
 * Path validation error
 */
export interface PathError extends ImportValidationError {
    code: 'ABSOLUTE_PATH' | 'INVALID_PATH_FORMAT';
}

/**
 * Import name validation error
 */
export interface ImportNameError extends ImportValidationError {
    code: 'DUPLICATE_IMPORT_NAME' | 'RESERVED_KEYWORD' | 'OPERATION_NAME_CONFLICT';
}

/**
 * Type inference validation error
 */
export interface TypeInferenceError extends ImportValidationError {
    code: 'UNKNOWN_EXTENSION' | 'AMBIGUOUS_EXTENSION';
    extension: string;
}

/**
 * Duplicate default import error
 */
export interface DuplicateDefaultImportError extends ImportValidationError {
    code: 'DUPLICATE_DEFAULT_IMPORT';
    importType: 'layout' | 'styles' | 'provider';
}


// =============================================================================
// Validator Functions (Pure, Testable)
// =============================================================================

/**
 * Validates that an import path is relative and portable
 *
 * Location: packages/language/src/validators/import-path-validator.ts
 *
 * @param path - File path from import statement (including quotes from AST)
 * @returns PathError if invalid, undefined if valid
 *
 * Validation Rules:
 * - MUST start with './' or '../'
 * - MUST NOT start with '/' (Unix absolute path)
 * - MUST NOT match /^[A-Z]:\\/ (Windows absolute path)
 * - MUST NOT start with protocol (http://, https://, file://)
 *
 * Examples:
 *   validateImportPath('./file.html')      // → undefined (valid)
 *   validateImportPath('../file.html')     // → undefined (valid)
 *   validateImportPath('/file.html')       // → PathError (absolute)
 *   validateImportPath('C:\\file.html')    // → PathError (absolute)
 *   validateImportPath('https://file')     // → PathError (absolute)
 */
export function validateImportPath(path: string): PathError | undefined;

/**
 * Validates that an import name is unique and not reserved
 *
 * Location: packages/language/src/validators/import-name-validator.ts
 *
 * @param name - Import identifier from named import
 * @param existingNames - Set of already-used import names in document
 * @param reservedKeywords - Set of language keywords (if, else, for, etc.)
 * @param operationNames - Set of built-in operation names (selectElement, etc.)
 * @returns ImportNameError if invalid, undefined if valid
 *
 * Validation Rules:
 * - MUST be unique within document
 * - MUST NOT be a reserved keyword
 * - MUST NOT conflict with built-in operation names
 *
 * Examples:
 *   validateImportName('tooltip', new Set(), keywords, ops)           // → undefined (valid)
 *   validateImportName('tooltip', new Set(['tooltip']), keywords, ops) // → ImportNameError (duplicate)
 *   validateImportName('if', new Set(), keywords, ops)                 // → ImportNameError (keyword)
 *   validateImportName('selectElement', new Set(), keywords, ops)      // → ImportNameError (operation)
 */
export function validateImportName(
    name: string,
    existingNames: Set<string>,
    reservedKeywords: Set<string>,
    operationNames: Set<string>
): ImportNameError | undefined;

/**
 * Validates that asset type can be inferred or is explicitly specified
 *
 * Location: packages/language/src/validators/asset-type-validator.ts
 *
 * @param path - File path from import statement
 * @param explicitType - Explicit type from 'as' clause (if provided)
 * @returns TypeInferenceError if invalid, undefined if valid
 *
 * Validation Rules:
 * - If explicitType provided → always valid
 * - If no explicitType → type MUST be inferrable from extension
 * - Unknown extensions (.xyz) → error (requires 'as' clause)
 * - Ambiguous extensions (.ogg) → error (requires 'as' clause)
 *
 * Examples:
 *   validateAssetType('./file.html', undefined)   // → undefined (valid, inferrable)
 *   validateAssetType('./file.xyz', undefined)    // → TypeInferenceError (unknown)
 *   validateAssetType('./file.xyz', 'html')       // → undefined (valid, explicit)
 *   validateAssetType('./file.ogg', undefined)    // → TypeInferenceError (ambiguous)
 */
export function validateAssetType(
    path: string,
    explicitType: AssetType | undefined
): TypeInferenceError | undefined;

/**
 * Validates that default imports are not duplicated
 *
 * Location: packages/language/src/validators/default-import-validator.ts
 *
 * @param imports - Array of all default imports in document
 * @returns Map of imports to errors (empty map if all valid)
 *
 * Validation Rules:
 * - At most ONE 'layout' import per document
 * - At most ONE 'styles' import per document
 * - At most ONE 'provider' import per document
 *
 * Examples:
 *   validateDefaultImports([layout1, styles1, provider1])  // → Map{} (valid)
 *   validateDefaultImports([layout1, layout2])             // → Map{layout2 → error}
 *   validateDefaultImports([styles1, styles2, styles3])    // → Map{styles2 → error, styles3 → error}
 */
export function validateDefaultImports(
    imports: DefaultImport[]
): Map<DefaultImport, DuplicateDefaultImportError>;


// =============================================================================
// Utility Functions
// =============================================================================

/**
 * Infers asset type from file extension
 *
 * Location: packages/language/src/utils/asset-type-inference.ts
 *
 * @param path - File path from import statement
 * @returns AssetType if inferrable, undefined if unknown/ambiguous
 *
 * Extension Mapping:
 * - .html → 'html'
 * - .css → 'css'
 * - .mp4, .webm → 'media'
 * - .mp3, .wav → 'media'
 * - .ogg → undefined (ambiguous: could be audio or video)
 * - .xyz → undefined (unknown extension)
 *
 * Case Handling:
 * - Extensions are case-insensitive (.HTML → 'html')
 * - Multiple extensions use final extension (.min.html → 'html')
 *
 * Examples:
 *   inferAssetType('./file.html')      // → 'html'
 *   inferAssetType('./file.HTML')      // → 'html'
 *   inferAssetType('./file.css')       // → 'css'
 *   inferAssetType('./file.mp4')       // → 'media'
 *   inferAssetType('./file.xyz')       // → undefined
 *   inferAssetType('./file.ogg')       // → undefined
 *   inferAssetType('./file.min.html')  // → 'html'
 */
export function inferAssetType(path: string): AssetType | undefined;

/**
 * Type guard for DefaultImport
 */
export function isDefaultImport(node: AstNode): node is DefaultImport;

/**
 * Type guard for NamedImport
 */
export function isNamedImport(node: AstNode): node is NamedImport;


// =============================================================================
// Langium Validator Adapters (Thin Wrappers)
// =============================================================================

/**
 * Langium validator class for import statements
 *
 * Location: packages/language/src/eligian-validator.ts
 *
 * NOTE: These are THIN ADAPTERS that call pure validator functions.
 * All business logic lives in validator functions above.
 */
export class ImportValidator {
    /**
     * Validates import path is relative and portable
     *
     * Calls: validateImportPath()
     */
    checkImportPath(
        import: DefaultImport | NamedImport,
        accept: ValidationAcceptor
    ): void;

    /**
     * Validates import names are unique and not reserved
     *
     * Calls: validateImportName() for each named import
     */
    checkImportNames(
        document: EligianDocument,
        accept: ValidationAcceptor
    ): void;

    /**
     * Validates asset types are inferrable or explicit
     *
     * Calls: validateAssetType() for each named import
     */
    checkAssetTypes(
        document: EligianDocument,
        accept: ValidationAcceptor
    ): void;

    /**
     * Validates default imports are not duplicated
     *
     * Calls: validateDefaultImports()
     */
    checkDefaultImports(
        document: EligianDocument,
        accept: ValidationAcceptor
    ): void;
}


// =============================================================================
// Error Message Templates
// =============================================================================

/**
 * Error messages and hints for user-facing validation errors
 *
 * All messages must be:
 * - Clear and actionable
 * - Beginner-friendly (no jargon)
 * - Include helpful hints for fixing the issue
 */
export const ERROR_MESSAGES = {
    // Path errors
    ABSOLUTE_PATH: {
        message: (path: string) =>
            `Import path must be relative (start with './' or '../'), absolute paths are not portable`,
        hint: `Use './filename.ext' or '../folder/filename.ext' for relative paths`
    },

    INVALID_PATH_FORMAT: {
        message: `Invalid path format`,
        hint: `Paths must be quoted strings starting with './' or '../'`
    },

    // Name errors
    DUPLICATE_IMPORT_NAME: {
        message: (name: string) =>
            `Duplicate import name '${name}', import names must be unique`,
        hint: `Choose a different name for this import`
    },

    RESERVED_KEYWORD: {
        message: (name: string) =>
            `Cannot use reserved keyword '${name}' as import name`,
        hint: `Reserved keywords: if, else, for, break, continue, at, action, timeline`
    },

    OPERATION_NAME_CONFLICT: {
        message: (name: string) =>
            `Cannot use operation name '${name}' as import name`,
        hint: (name: string) =>
            `'${name}' is a built-in operation. Choose a different import name`
    },

    // Type inference errors
    UNKNOWN_EXTENSION: {
        message: (ext: string) =>
            `Unknown file extension '.${ext}', please specify type: import foo from './file.${ext}' as html|css|media`,
        hint: `Add 'as html', 'as css', or 'as media' to specify the asset type`
    },

    AMBIGUOUS_EXTENSION: {
        message: (ext: string) =>
            `Ambiguous file extension '.${ext}', please specify type explicitly`,
        hint: `Add 'as media' to clarify this is a media file`
    },

    // Default import errors
    DUPLICATE_DEFAULT_IMPORT: {
        message: (type: string) =>
            `Duplicate '${type}' import, only one ${type} import is allowed`,
        hint: (type: string) =>
            `Remove duplicate ${type} import statements`
    }
};


// =============================================================================
// Constants
// =============================================================================

/**
 * Reserved keywords that cannot be used as import names
 */
export const RESERVED_KEYWORDS = new Set([
    'if', 'else', 'for', 'break', 'continue',
    'at', 'action', 'timeline', 'layout', 'styles', 'provider',
    'import', 'from', 'as', 'true', 'false'
]);

/**
 * File extension to asset type mapping
 */
export const EXTENSION_MAP: Record<string, AssetType> = {
    'html': 'html',
    'css': 'css',
    'mp4': 'media',
    'webm': 'media',
    'mp3': 'media',
    'wav': 'media'
    // .ogg intentionally excluded (ambiguous)
};

/**
 * Ambiguous extensions that require explicit type specification
 */
export const AMBIGUOUS_EXTENSIONS = new Set(['ogg']);


// =============================================================================
// Testing Contract
// =============================================================================

/**
 * All validator functions MUST have unit tests covering:
 *
 * validateImportPath:
 * - Valid relative paths (./file, ../file, ./nested/file)
 * - Invalid absolute paths (/file, C:\file, https://file)
 * - Edge cases (empty, no extension, deeply nested)
 *
 * validateImportName:
 * - Valid unique names
 * - Duplicate names
 * - Reserved keyword conflicts
 * - Operation name conflicts
 *
 * validateAssetType:
 * - Known extensions (.html, .css, .mp4)
 * - Unknown extensions (.xyz)
 * - Ambiguous extensions (.ogg)
 * - Case-insensitive (.HTML)
 * - Multiple extensions (.min.html)
 * - Explicit type override
 *
 * validateDefaultImports:
 * - No duplicates (valid)
 * - Duplicate layout/styles/provider
 * - Mixed types (valid)
 *
 * inferAssetType:
 * - All extension mappings
 * - Case insensitivity
 * - Multiple extensions
 * - Unknown/ambiguous extensions
 */
