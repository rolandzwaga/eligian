# Data Model: Asset Import Syntax

**Date**: 2025-10-25
**Feature**: Asset Import Syntax
**Based on**: spec.md, research.md

## Overview

This document defines the data structures (AST nodes, types, and validation errors) for the Asset Import Syntax feature. All structures are generated from Langium grammar rules or defined as pure TypeScript types for validation.

---

## AST Node Types

### DefaultImport

Represents a default import statement (`layout`, `styles`, or `provider`) that auto-assigns to a configuration property.

**Grammar Rule**:
```langium
DefaultImport:
    type=('layout' | 'styles' | 'provider') path=STRING;
```

**Generated TypeScript Interface** (automatic from Langium):
```typescript
interface DefaultImport extends AstNode {
    $type: 'DefaultImport';
    type: 'layout' | 'styles' | 'provider';
    path: string;
}
```

**Properties**:
- `type`: Which configuration property this import assigns to
  - `'layout'` → assigns to `layoutTemplate` property
  - `'styles'` → registers CSS for future completions
  - `'provider'` → assigns to `timelineProvider.source`
- `path`: Relative file path (string including quotes from DSL source)

**Example DSL**:
```eligian
layout './layout.html'
styles './main.css'
provider './video.mp4'
```

**Validation Rules** (see Validators section below):
- Path must be relative (start with `./` or `../`)
- Path must not be absolute (`/`, `C:\`, `https://`)
- No duplicate default imports of same type (e.g., two `layout` imports)

---

### NamedImport

Represents a named import statement with an identifier, allowing reuse throughout the document.

**Grammar Rule**:
```langium
NamedImport:
    'import' name=ID 'from' path=STRING ('as' assetType=('html' | 'css' | 'media'))?;
```

**Generated TypeScript Interface** (automatic from Langium):
```typescript
interface NamedImport extends AstNode {
    $type: 'NamedImport';
    name: string;
    path: string;
    assetType?: 'html' | 'css' | 'media';
}
```

**Properties**:
- `name`: Identifier for referencing this import (e.g., `tooltip`, `modal`)
- `path`: Relative file path (string including quotes from DSL source)
- `assetType`: Optional explicit type override
  - `undefined` → type inferred from file extension
  - `'html' | 'css' | 'media'` → explicitly specified

**Example DSL**:
```eligian
import tooltip from './tooltip.html'
import theme from './theme.css'
import video from './intro.mp4'
import data from './template.txt' as html  // explicit type
```

**Validation Rules** (see Validators section below):
- Path must be relative (start with `./` or `../`)
- Path must not be absolute
- Name must be unique (no duplicate import names)
- Name must not conflict with reserved keywords (`if`, `else`, `for`, `break`, `continue`)
- Name must not conflict with built-in operation names (`selectElement`, `animate`, etc.)
- If `assetType` is undefined, type must be inferrable from extension
  - Unknown extensions require explicit `as type` suffix

---

### ImportStatement (Union Type)

Union type for validators and traversal functions to handle both import types uniformly.

**TypeScript Type** (generated by Langium):
```typescript
type ImportStatement = DefaultImport | NamedImport;
```

**Type Guards**:
```typescript
function isDefaultImport(node: AstNode): node is DefaultImport {
    return node.$type === 'DefaultImport';
}

function isNamedImport(node: AstNode): node is NamedImport {
    return node.$type === 'NamedImport';
}
```

---

## Supporting Types

### AssetType (Enum)

Classification of asset files by their purpose.

**TypeScript Type**:
```typescript
type AssetType = 'html' | 'css' | 'media';
```

**Values**:
- `'html'`: HTML files for layouts and content snippets
- `'css'`: CSS stylesheets for styling and class definitions
- `'media'`: Video and audio files for timeline providers

**Extension Mapping** (see Type Inference Utility below):
- `.html` → `'html'`
- `.css` → `'css'`
- `.mp4`, `.webm` → `'media'` (video)
- `.mp3`, `.wav` → `'media'` (audio)
- `.ogg` → ambiguous (requires explicit `as media`)

---

### ImportPath (Validation Type)

Represents a validated relative file path.

**TypeScript Type**:
```typescript
type ImportPath = string & { readonly __brand: 'ImportPath' };
```

**Validation**:
- Must start with `./` or `../`
- Must not start with `/` (Unix absolute path)
- Must not match `^[A-Z]:\\` (Windows absolute path like `C:\`)
- Must not start with protocol (`http://`, `https://`, `file://`)

**Helper Function**:
```typescript
function isRelativePath(path: string): boolean {
    return path.startsWith('./') || path.startsWith('../');
}

function isAbsolutePath(path: string): boolean {
    // Unix absolute path
    if (path.startsWith('/')) return true;

    // Windows absolute path (C:\, D:\, etc.)
    if (/^[A-Za-z]:[\\/]/.test(path)) return true;

    // Protocol (http://, https://, file://)
    if (/^[a-z]+:\/\//i.test(path)) return true;

    return false;
}
```

---

## Validation Errors

### PathError

Error type for path validation failures.

**TypeScript Interface**:
```typescript
interface PathError {
    code: 'ABSOLUTE_PATH' | 'INVALID_PATH_FORMAT';
    message: string;
    hint: string;
}
```

**Error Codes**:
- `ABSOLUTE_PATH`: Path is absolute (starts with `/`, `C:\`, or protocol)
  - **Message**: `"Import path must be relative (start with './' or '../'), absolute paths are not portable"`
  - **Hint**: `"Use './filename.ext' or '../folder/filename.ext' for relative paths"`

- `INVALID_PATH_FORMAT`: Path format is invalid
  - **Message**: `"Invalid path format"`
  - **Hint**: `"Paths must be quoted strings starting with './' or '../'"`

---

### ImportNameError

Error type for import name validation failures.

**TypeScript Interface**:
```typescript
interface ImportNameError {
    code: 'DUPLICATE_IMPORT_NAME' | 'RESERVED_KEYWORD' | 'OPERATION_NAME_CONFLICT';
    message: string;
    hint: string;
}
```

**Error Codes**:
- `DUPLICATE_IMPORT_NAME`: Import name already used
  - **Message**: `"Duplicate import name '{name}', import names must be unique"`
  - **Hint**: `"Choose a different name for this import"`

- `RESERVED_KEYWORD`: Import name is a reserved keyword
  - **Message**: `"Cannot use reserved keyword '{name}' as import name"`
  - **Hint**: `"Reserved keywords: if, else, for, break, continue, at, action, timeline"`

- `OPERATION_NAME_CONFLICT`: Import name conflicts with built-in operation
  - **Message**: `"Cannot use operation name '{name}' as import name"`
  - **Hint**: `"'{name}' is a built-in operation. Choose a different import name"`

---

### TypeInferenceError

Error type for type inference failures.

**TypeScript Interface**:
```typescript
interface TypeInferenceError {
    code: 'UNKNOWN_EXTENSION' | 'AMBIGUOUS_EXTENSION';
    message: string;
    hint: string;
    extension: string;
}
```

**Error Codes**:
- `UNKNOWN_EXTENSION`: File extension is not recognized
  - **Message**: `"Unknown file extension '.{ext}', please specify type: import foo from './file.{ext}' as html|css|media"`
  - **Hint**: `"Add 'as html', 'as css', or 'as media' to specify the asset type"`

- `AMBIGUOUS_EXTENSION`: Extension could be multiple types (e.g., `.ogg`)
  - **Message**: `"Ambiguous file extension '.ogg', please specify type explicitly"`
  - **Hint**: `"Add 'as media' to clarify this is a media file"`

---

### DuplicateDefaultImportError

Error type for duplicate default imports.

**TypeScript Interface**:
```typescript
interface DuplicateDefaultImportError {
    code: 'DUPLICATE_DEFAULT_IMPORT';
    message: string;
    hint: string;
    importType: 'layout' | 'styles' | 'provider';
}
```

**Error Code**:
- `DUPLICATE_DEFAULT_IMPORT`: Multiple default imports of same type
  - **Message**: `"Duplicate '{type}' import, only one {type} import is allowed"`
  - **Hint**: `"Remove duplicate {type} import statements"`

---

## Utility Functions

### Type Inference Utility

Location: `packages/language/src/utils/asset-type-inference.ts`

**Function Signature**:
```typescript
export function inferAssetType(path: string): AssetType | undefined
```

**Purpose**: Infers asset type from file extension

**Implementation**:
```typescript
export function inferAssetType(path: string): AssetType | undefined {
    const ext = path.match(/\.([^.]+)$/)?.[1]?.toLowerCase();
    if (!ext) return undefined;

    const extensionMap: Record<string, AssetType> = {
        'html': 'html',
        'css': 'css',
        'mp4': 'media',
        'webm': 'media',
        'mp3': 'media',
        'wav': 'media',
        // .ogg excluded - ambiguous (audio or video)
    };

    return extensionMap[ext];
}
```

**Test Cases**:
```typescript
inferAssetType('./file.html')     // → 'html'
inferAssetType('./file.HTML')     // → 'html' (case-insensitive)
inferAssetType('./file.css')      // → 'css'
inferAssetType('./file.mp4')      // → 'media'
inferAssetType('./file.xyz')      // → undefined (unknown extension)
inferAssetType('./file.ogg')      // → undefined (ambiguous)
inferAssetType('./file.min.html') // → 'html' (uses final extension)
```

---

## Validators

All validators follow Constitution Principle X (Compiler-First Validation): pure functions returning typed errors, with Langium validators as thin adapters.

### Path Validator

Location: `packages/language/src/validators/import-path-validator.ts`

**Function Signature**:
```typescript
export function validateImportPath(path: string): PathError | undefined
```

**Purpose**: Validates path is relative and portable

**Returns**:
- `undefined` if valid
- `PathError` if invalid

**Langium Adapter**:
```typescript
// In eligian-validator.ts
checkImportPath(
    import: DefaultImport | NamedImport,
    accept: ValidationAcceptor
): void {
    const error = validateImportPath(import.path);
    if (error) {
        accept('error', `${error.message}. ${error.hint}`, {
            node: import,
            property: 'path',
            code: error.code
        });
    }
}
```

---

### Import Name Validator

Location: `packages/language/src/validators/import-name-validator.ts`

**Function Signature**:
```typescript
export function validateImportName(
    name: string,
    existingNames: Set<string>,
    reservedKeywords: Set<string>,
    operationNames: Set<string>
): ImportNameError | undefined
```

**Purpose**: Validates import name is unique and not reserved

**Returns**:
- `undefined` if valid
- `ImportNameError` if invalid

**Langium Adapter**:
```typescript
// In eligian-validator.ts
checkImportNames(document: EligianDocument, accept: ValidationAcceptor): void {
    const existingNames = new Set<string>();

    for (const import of document.imports) {
        if (isNamedImport(import)) {
            const error = validateImportName(
                import.name,
                existingNames,
                RESERVED_KEYWORDS,
                OPERATION_NAMES
            );

            if (error) {
                accept('error', `${error.message}. ${error.hint}`, {
                    node: import,
                    property: 'name',
                    code: error.code
                });
            } else {
                existingNames.add(import.name);
            }
        }
    }
}
```

---

### Type Inference Validator

Location: `packages/language/src/validators/asset-type-validator.ts`

**Function Signature**:
```typescript
export function validateAssetType(
    path: string,
    explicitType: AssetType | undefined
): TypeInferenceError | undefined
```

**Purpose**: Validates asset type can be inferred or is explicitly specified

**Returns**:
- `undefined` if valid (type inferrable or explicit)
- `TypeInferenceError` if invalid (unknown/ambiguous extension without explicit type)

**Langium Adapter**:
```typescript
// In eligian-validator.ts
checkAssetType(import: NamedImport, accept: ValidationAcceptor): void {
    const error = validateAssetType(import.path, import.assetType);
    if (error) {
        accept('error', `${error.message}. ${error.hint}`, {
            node: import,
            property: 'path',
            code: error.code
        });
    }
}
```

---

### Default Import Validator

Location: `packages/language/src/validators/default-import-validator.ts`

**Function Signature**:
```typescript
export function validateDefaultImports(
    imports: DefaultImport[]
): Map<DefaultImport, DuplicateDefaultImportError>
```

**Purpose**: Validates no duplicate default imports of same type

**Returns**: Map of imports to errors (empty if all valid)

**Langium Adapter**:
```typescript
// In eligian-validator.ts
checkDefaultImports(document: EligianDocument, accept: ValidationAcceptor): void {
    const defaultImports = document.imports.filter(isDefaultImport);
    const errors = validateDefaultImports(defaultImports);

    for (const [import, error] of errors) {
        accept('error', `${error.message}. ${error.hint}`, {
            node: import,
            property: 'type',
            code: error.code
        });
    }
}
```

---

## Document Structure Update

The `EligianDocument` AST node is extended with an `imports` array.

**Updated Grammar Rule**:
```langium
entry EligianDocument:
    (imports+=ImportStatement)*
    (actions+=Action | timeline=Timeline)+;
```

**Generated TypeScript Interface**:
```typescript
interface EligianDocument extends AstNode {
    $type: 'EligianDocument';
    imports: ImportStatement[];  // NEW: array of import statements
    actions: Action[];
    timeline?: Timeline;
}
```

---

## Testing Strategy

### Unit Tests

**Import Path Validator** (`import-path-validator.spec.ts`):
- Valid relative paths (`./file`, `../file`, `./nested/file`)
- Invalid absolute paths (`/file`, `C:\file`, `https://file`)
- Edge cases (empty string, no extension, deeply nested)

**Import Name Validator** (`import-name-validator.spec.ts`):
- Valid unique names
- Duplicate names
- Reserved keyword conflicts
- Operation name conflicts

**Asset Type Validator** (`asset-type-validator.spec.ts`):
- Known extensions (`.html`, `.css`, `.mp4`)
- Unknown extensions (`.xyz`)
- Ambiguous extensions (`.ogg`)
- Case-insensitive handling (`.HTML`)
- Multiple extensions (`.min.html`)

**Default Import Validator** (`default-import-validator.spec.ts`):
- No duplicates (valid)
- Duplicate layout imports
- Duplicate styles imports
- Duplicate provider imports
- Mixed import types (valid)

### Integration Tests

**Parsing Tests** (`parsing.spec.ts`):
- Parse default imports
- Parse named imports
- Parse named imports with explicit type
- Parse mixed default and named imports
- Parse imports with actions and timeline

**Validation Tests** (`validation.spec.ts`):
- Validate path errors
- Validate name conflicts
- Validate type inference errors
- Validate duplicate default imports
- Validate complete documents with imports

---

## Summary

This data model provides:

1. **AST Node Types**: `DefaultImport`, `NamedImport` (generated by Langium)
2. **Supporting Types**: `AssetType`, `ImportPath`
3. **Error Types**: `PathError`, `ImportNameError`, `TypeInferenceError`, `DuplicateDefaultImportError`
4. **Validators**: Pure functions for all validation rules
5. **Utilities**: `inferAssetType()` for type inference

All validators follow Constitution Principle X: pure functions with Langium validators as thin adapters.
