# Data Model: Event Actions with Declarative Syntax

**Feature**: 028-event-actions-the
**Date**: 2025-11-09
**Phase**: Phase 1 (Design)

## Overview

This document defines the data structures, entities, and relationships for the Event Actions feature. The data model covers both compile-time (DSL AST) and runtime (Eligius JSON configuration) representations.

## Entities

### 1. EventActionDefinition (AST Node)

**Purpose**: Represents an event-triggered action definition in the Eligian DSL AST.

**Location**: Langium grammar (`packages/language/src/eligian.langium`)

**Structure**:

```typescript
interface EventActionDefinition extends AstNode {
  eventName: string;             // Event identifier (must be string literal)
  eventTopic?: string;           // Optional topic for namespacing (must be string literal)
  name: string;                  // Action name (identifier)
  parameters: Parameter[];       // Parameter list (can be empty)
  operations: OperationStatement[];  // Action body operations (must not be empty)
}

interface Parameter extends AstNode {
  name: string;                  // Parameter identifier
  type?: TypeAnnotation;         // Optional type annotation (future: type checking)
}
```

**Validation Rules**:
- `eventName` MUST be a non-empty string literal (not variable/expression)
- `eventTopic` (if present) MUST be a non-empty string literal
- `name` MUST follow action naming rules (alphanumeric + underscores)
- `name` MUST NOT conflict with reserved keywords
- `parameters` names MUST be valid identifiers
- `parameters` names MUST NOT be reserved keywords (`if`, `for`, `break`, `continue`, etc.)
- `parameters` names MUST NOT have duplicates within same event action
- `operations` MUST contain at least one operation (empty bodies are errors)

**Relationships**:
- Contains 0-N `Parameter` nodes
- Contains 1-N `OperationStatement` nodes
- Is contained by `Program` node (top-level construct)

**Example DSL**:

```eligian
on event "language-change" topic "user-selection" action HandleLanguageChange(languageCode) [
  selectElement(".language-display")
  setTextContent(languageCode)
]
```

### 2. IEventActionConfiguration (Runtime JSON)

**Purpose**: Eligius runtime configuration for event-triggered actions.

**Location**: Eligius type definitions (`f:\projects\eligius\eligius\src\configuration\types.ts:113-136`)

**Structure**:

```typescript
interface IEventActionConfiguration {
  id: string;                   // UUID v4 (generated by compiler)
  name: string;                 // Action name from DSL
  eventName: string;            // Event identifier from DSL
  eventTopic?: string;          // Optional topic from DSL
  startOperations: IOperationConfiguration<TOperationData>[];  // Compiled operations
}

interface IOperationConfiguration<T extends TOperationData> {
  id: string;                   // UUID v4 for each operation
  systemName: string;           // Operation name (e.g., "selectElement")
  operationData?: T;            // Operation-specific parameters
}
```

**Constraints**:
- `id` MUST be UUID v4 (per Constitution Principle VII)
- `eventName` MUST be non-empty string
- `eventTopic` MAY be undefined (optional)
- `startOperations` MUST contain at least one operation
- Each operation `id` MUST be UUID v4
- Operation `systemName` MUST reference valid Eligius operation

**Relationships**:
- Contained in `IEngineConfiguration.eventActions[]` array
- Each event action contains 1-N `IOperationConfiguration` objects
- No relationship to `actions` or `initActions` (separate namespace)

**Example JSON**:

```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "name": "HandleLanguageChange",
  "eventName": "language-change",
  "eventTopic": "user-selection",
  "startOperations": [
    {
      "id": "op-uuid-1",
      "systemName": "selectElement",
      "operationData": {
        "selector": ".language-display"
      }
    },
    {
      "id": "op-uuid-2",
      "systemName": "setTextContent",
      "operationData": {
        "textContent": "$operationData.eventArgs[0]"
      }
    }
  ]
}
```

### 3. EventActionParameter (Transformation Context)

**Purpose**: Tracks parameter names and their mapping to `eventArgs` indices during AST transformation.

**Location**: Compiler transformation logic (`packages/compiler/src/ast-transformer.ts`)

**Structure**:

```typescript
interface EventActionContext {
  parameters: Map<string, number>;  // paramName → eventArgs index
}

// Example usage during transformation:
const context: EventActionContext = {
  parameters: new Map([
    ['languageCode', 0],  // First parameter → eventArgs[0]
    ['timestamp', 1],     // Second parameter → eventArgs[1]
  ])
};
```

**Constraints**:
- Parameter indices are zero-based (first param = 0)
- Parameter names are case-sensitive
- Parameter context is scoped to single event action (not global)

**Lifecycle**:
- Created when transforming `EventActionDefinition` node
- Used when transforming operation references within event action body
- Discarded after event action transformation completes

**Example Transformation**:

```typescript
// DSL:
on event "user-click" action HandleClick(element, timestamp) [
  logEvent(element, timestamp)
]

// Transformation context:
parameters: Map {
  'element' => 0,
  'timestamp' => 1
}

// Compiled operation:
{
  "systemName": "logEvent",
  "operationData": {
    "message": "$operationData.eventArgs[0]",  // element
    "timestamp": "$operationData.eventArgs[1]" // timestamp
  }
}
```

## State Transitions

### Event Action Lifecycle

```
[DSL Source]
     │
     ├─ Parse (Langium) ──→ [EventActionDefinition AST]
     │                              │
     ├─ Validate ──→ [Check constraints, emit diagnostics]
     │                              │
     ├─ Transform ──→ [Create parameter context]
     │                              │
     │                       [Map parameters → indices]
     │                              │
     │                       [Transform operations with context]
     │                              │
     └─ Generate JSON ──→ [IEventActionConfiguration]
                                    │
                            [Add to config.eventActions[]]
                                    │
                            [Eligius Runtime: Register with eventbus]
                                    │
                            [Wait for event dispatch]
                                    │
                            [Event broadcast with args]
                                    │
                            [Execute startOperations with eventArgs]
```

### Parameter Resolution Flow

```
[Reference in operation]
     │
     ├─ Is event action parameter? ──yes──→ [Resolve to $operationData.eventArgs[n]]
     │                              │
     │                              no
     │                              │
     ├─ Is constant? ──yes──→ [Resolve to constant value]
     │                 │
     │                 no
     │                 │
     ├─ Is variable? ──yes──→ [Resolve to $scope.variables.varName]
     │                 │
     │                 no
     │                 │
     └─ Is system property? ──yes──→ [Resolve to @@loopIndex, @@currentItem, etc.]
                           │
                           no
                           │
                    [ERROR: Undefined reference]
```

## Validation Rules

### Compile-Time Validation

| Rule | Severity | Message Template |
|------|----------|------------------|
| **Event name must be string literal** | Error | `Event name must be a string literal, not a variable or expression` |
| **Event topic must be string literal (if present)** | Error | `Event topic must be a string literal, not a variable or expression` |
| **Event action name must be valid identifier** | Error | `Invalid action name '${name}': must contain only alphanumeric characters and underscores` |
| **Parameter name must not be reserved keyword** | Error | `Parameter name '${name}' is a reserved keyword (if, for, break, continue, etc.)` |
| **Duplicate parameter names** | Error | `Duplicate parameter '${name}' in event action '${actionName}'` |
| **Empty action body** | Error | `Event action '${actionName}' must have at least one operation` |
| **Duplicate event/topic combination** | Warning | `Multiple event actions registered for event '${eventName}'${topic ? ` topic '${topic}'` : ''}` |
| **Undefined parameter reference** | Error | `Parameter '${paramName}' is not defined in event action '${actionName}'` |

### Runtime Constraints

| Constraint | Enforcement | Failure Behavior |
|-----------|-------------|------------------|
| **Event must be broadcast before action executes** | Eligius eventbus | Action never executes (no error) |
| **eventArgs array must match parameter count** | None (runtime mismatch) | Excess params = undefined, missing args ignored |
| **Event action operations must be valid** | Eligius operation resolver | Runtime error on invalid operation |

## Data Flow Diagrams

### Event Dispatch → Action Execution

```
[Event Dispatcher]
     │
     ├─ broadcastEvent("click", ["#button", 1234567890])
     │
[Eventbus]
     │
     ├─ Look up handlers for "click"
     │
[ActionRegistryListener]
     │
     ├─ Create operationData: { eventArgs: ["#button", 1234567890] }
     │
[Action.start(operationData)]
     │
[Operation 1: selectElement]
     │
     ├─ Read operationData.eventArgs[0] → "#button"
     │
[Operation 2: logEvent]
     │
     └─ Read operationData.eventArgs[1] → 1234567890
```

### Parameter Mapping (Compile-Time)

```
DSL:
on event "click" action HandleClick(element, timestamp) [
  selectElement(element)
  logEvent(timestamp)
]

Parameter Context Creation:
  parameters = Map {
    'element' => 0,
    'timestamp' => 1
  }

Operation Transform (selectElement):
  Input:  selectElement(element)
  Lookup: context.parameters.get('element') → 0
  Output: { systemName: "selectElement", operationData: { selector: "$operationData.eventArgs[0]" } }

Operation Transform (logEvent):
  Input:  logEvent(timestamp)
  Lookup: context.parameters.get('timestamp') → 1
  Output: { systemName: "logEvent", operationData: { message: "$operationData.eventArgs[1]" } }
```

## Integration Points

### Langium Grammar

**File**: `packages/language/src/eligian.langium`

**Integration**:

```
Program:
  (elements+=ProgramElement)*
;

ProgramElement:
    ActionDeclaration
  | TimelineDeclaration
  | EventActionDefinition  // ← NEW
  | ConstantDeclaration
  | StylesImport
;

EventActionDefinition:
  'on' 'event' eventName=STRING
  ('topic' eventTopic=STRING)?
  'action' name=ID
  '(' (parameters+=ID (',' parameters+=ID)*)? ')'
  '[' operations+=OperationStatement* ']'
;
```

### AST Transformer

**File**: `packages/compiler/src/ast-transformer.ts`

**Integration**:

```typescript
function transformProgram(program: Program): IEngineConfiguration {
  const config: IEngineConfiguration = {
    // ... existing fields
    eventActions: []  // ← NEW
  };

  for (const element of program.elements) {
    if (isEventActionDefinition(element)) {
      config.eventActions.push(transformEventAction(element));
    }
    // ... existing transformations
  }

  return config;
}
```

### Validator

**File**: `packages/language/src/eligian-validator.ts`

**Integration**:

```typescript
@Check()
checkEventActionDefinition(eventAction: EventActionDefinition, accept: ValidationAcceptor): void {
  // Validate event name is string literal
  // Validate event topic is string literal (if present)
  // Validate action name
  // Validate parameters (no reserved keywords, no duplicates)
  // Validate non-empty operations
  // Warn on duplicate (eventName, eventTopic) combinations
}

@Check()
checkEventActionParameterReference(ref: Reference, accept: ValidationAcceptor): void {
  // Check if reference is to event action parameter
  // Validate parameter exists in current event action scope
}
```

## Example Use Cases

### Use Case 1: Language Change Handler

**DSL**:

```eligian
on event "language-change" action UpdateLanguageDisplay(languageCode) [
  selectElement(".language-display")
  setTextContent(languageCode)
]
```

**Compiled JSON**:

```json
{
  "eventActions": [
    {
      "id": "uuid-1",
      "name": "UpdateLanguageDisplay",
      "eventName": "language-change",
      "startOperations": [
        {
          "id": "uuid-2",
          "systemName": "selectElement",
          "operationData": { "selector": ".language-display" }
        },
        {
          "id": "uuid-3",
          "systemName": "setTextContent",
          "operationData": { "textContent": "$operationData.eventArgs[0]" }
        }
      ]
    }
  ]
}
```

### Use Case 2: Click Handler with Topic

**DSL**:

```eligian
on event "click" topic "navigation" action HandleNavClick(target) [
  selectElement(target)
  addClass("active")
]

on event "click" topic "form-submission" action HandleFormClick(formId) [
  selectElement(formId)
  submitForm()
]
```

**Compiled JSON**:

```json
{
  "eventActions": [
    {
      "id": "uuid-1",
      "name": "HandleNavClick",
      "eventName": "click",
      "eventTopic": "navigation",
      "startOperations": [/* ... */]
    },
    {
      "id": "uuid-2",
      "name": "HandleFormClick",
      "eventName": "click",
      "eventTopic": "form-submission",
      "startOperations": [/* ... */]
    }
  ]
}
```

### Use Case 3: Zero-Parameter Event Action

**DSL**:

```eligian
on event "timeline-complete" action OnComplete [
  selectElement("#completion-message")
  removeClass("hidden")
]
```

**Compiled JSON**:

```json
{
  "eventActions": [
    {
      "id": "uuid-1",
      "name": "OnComplete",
      "eventName": "timeline-complete",
      "startOperations": [/* ... */]
    }
  ]
}
```

## Performance Considerations

### Compile-Time Performance

- **Parameter context creation**: O(n) where n = number of parameters (typically < 10)
- **Parameter lookup during transform**: O(1) with Map data structure
- **Validation overhead**: O(m) where m = number of event actions (typically < 100)

### Runtime Performance

- **Event registration**: O(1) lookup in eventbus registry (Map-based)
- **Event dispatch**: O(k) where k = number of handlers for event (typically 1-5)
- **Parameter resolution**: O(1) array index access

### Memory Footprint

- **AST nodes**: ~200-500 bytes per EventActionDefinition
- **Compiled JSON**: ~300-800 bytes per IEventActionConfiguration (depends on operations)
- **Parameter context**: ~50-100 bytes during transformation (temporary)

## Future Enhancements

### Potential Extensions (Not in Current Scope)

1. **Event Argument Type Checking**:
   - Requires Eligius to expose typed event metadata
   - Would enable compile-time validation: `on event "click" action HandleClick(element: HTMLElement)`

2. **Event Name Autocomplete from Eligius**:
   - Extract event names from Eligius `TimelineEventNames` enum
   - Provide autocomplete suggestions in IDE

3. **Event Action Composition**:
   - Allow calling other event actions from event action bodies
   - Requires parameter forwarding mechanism

4. **Conditional Event Handling**:
   - Syntax: `on event "click" when condition action ...`
   - Enables guard clauses for event actions

These enhancements are deferred per Constitution Principle III (No Gold-Plating).

## Summary

The Event Actions data model consists of three primary entities:

1. **EventActionDefinition**: Compile-time AST representation with validation rules
2. **IEventActionConfiguration**: Runtime JSON configuration for Eligius
3. **EventActionContext**: Transformation state for parameter → eventArgs mapping

The model supports the full event action lifecycle from DSL parsing through runtime execution, with clear validation rules and state transitions at each stage.
