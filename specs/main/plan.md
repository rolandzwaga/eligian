# Implementation Plan: Break and Continue Syntactic Sugar

**Branch**: `main` | **Date**: 2025-10-18 | **Spec**: [spec.md](spec.md)

## Summary

Add `break` and `continue` keywords to the Eligian DSL as syntactic sugar for `breakForEach` and `continueForEach` operations. This provides familiar control flow syntax that matches common programming languages, improving developer experience while maintaining 100% backwards compatibility with existing code.

**Technical Approach**:
1. Extend Langium grammar with `BreakStatement` and `ContinueStatement`
2. Transform statements to operation calls in AST transformer
3. Add validation to ensure keywords only appear inside loops
4. Comprehensive testing at all layers (parsing, validation, transformation, integration)

## Technical Context

**Language/Version**: TypeScript 5.x with Node.js 20+
**Primary Dependencies**: Langium 3.x, Effect-ts 3.x, Vitest 3.x
**Testing**: Vitest for unit and integration tests
**Target Platform**: Node.js CLI + VS Code extension
**Project Type**: Single project (monorepo with packages)
**Performance Goals**: No measurable impact on compilation time (<1ms overhead)
**Constraints**:
- Zero breaking changes (existing DSL code must work)
- Langium grammar must remain deterministic (no ambiguity)
- Generated Eligius JSON must match existing operation patterns

**Scale/Scope**:
- Grammar: +2 statement types
- Transformer: +2 transformation functions
- Validator: +2 validation rules
- Tests: ~15-20 new tests across 4 test suites

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with `.specify/memory/constitution.md`:

- [x] **Simplicity & Documentation**: Clear syntactic sugar pattern matching existing `if/else` and `for` patterns. Well-documented in spec.
- [x] **Comprehensive Testing**: Unit tests for parsing, validation, transformation, and integration tests planned.
- [x] **No Gold-Plating**: Solves real need (developer ergonomics) without unnecessary features (no labels, no advanced patterns).
- [x] **Code Review**: Standard PR process applies.
- [x] **UX Consistency**: Follows existing syntactic sugar patterns (`for`, `if/else`). Consistent error messages.
- [x] **Functional Programming**: Pure transformation functions, Effect-ts for composition. No mutation of AST.
- [x] **Operation Metadata Consultation**: `breakForEach` and `continueForEach` metadata already verified in registry.
- [x] **Biome Integration**: Will run `npm run check` after each phase.
- [x] **ESM Import Extensions**: All imports use `.js` extensions.
- [x] **Validation Pattern**: Validation will be compiler-first (though simple AST walking).

*All checks pass. No complexity tracking needed - this is a straightforward feature following established patterns.*

## Project Structure

### Documentation (this feature)

```
specs/main/
├── plan.md              # This file
├── spec.md              # Feature specification (already created)
└── tasks.md             # Will be generated by /speckit.tasks command
```

### Source Code (repository root)

```
packages/language/
├── src/
│   ├── eligian.langium                              # ← Grammar (add BreakStatement, ContinueStatement)
│   ├── generated/
│   │   └── ast.ts                                   # ← Generated AST types (auto-updated by Langium)
│   ├── eligian-validator.ts                        # ← Add checkBreakStatement, checkContinueStatement
│   ├── compiler/
│   │   ├── ast-transformer.ts                      # ← Add transformBreakStatement, transformContinueStatement
│   │   └── __tests__/
│   │       └── transformer.spec.ts                 # ← Add transformer tests
│   └── __tests__/
│       ├── parsing.spec.ts                         # ← Add parsing tests
│       └── validation.spec.ts                      # ← Add validation tests
│
examples/
└── loop-control-demo.eligian                       # ← New example file

CLAUDE.md                                            # ← Update with new syntax patterns
```

## Phase 0: Research & Discovery

**Goal**: Resolve any unknowns and validate design decisions.

### Research Tasks

1. **Verify Langium Grammar Patterns**
   - ✅ Review existing statement patterns (`IfStatement`, `ForStatement`)
   - ✅ Confirm keyword syntax (simple terminal rules)
   - ✅ Check for grammar conflicts with existing keywords

2. **Verify Transformer Patterns**
   - ✅ Review how `IfStatement` → `when/otherwise/endWhen`
   - ✅ Review how `ForStatement` → `forEach/endForEach`
   - ✅ Confirm operation generation pattern

3. **Verify Validation Patterns**
   - ✅ Review existing validators in `eligian-validator.ts`
   - ✅ Check AST utility functions for parent node traversal
   - ✅ Confirm ValidationAcceptor usage patterns

### Findings

**Grammar Pattern**:
```langium
// Existing pattern for simple statements
VariableDeclaration:
    'const' name=ID '=' value=Expression;

// Our pattern (even simpler - no parameters)
BreakStatement:
    'break';

ContinueStatement:
    'continue';
```

**Transformer Pattern**:
```typescript
// Existing pattern: IfStatement → when/otherwise/endWhen operations
function* transformIfStatement(stmt: IfStatement, scope?: ScopeContext): Effect.Effect<OperationConfigIR[], TransformError> {
  const operations: OperationConfigIR[] = [];
  operations.push({ systemName: 'when', operationData: { ... } });
  // ... transform body ...
  operations.push({ systemName: 'endWhen', operationData: {} });
  return operations;
}

// Our pattern (simpler - single operation, no nesting)
function* transformBreakStatement(stmt: BreakStatement, scope?: ScopeContext): Effect.Effect<OperationConfigIR[], TransformError> {
  return [{ systemName: 'breakForEach', operationData: {} }];
}
```

**Validation Pattern**:
```typescript
// Existing pattern: Walk up AST to check context
import { AstUtils } from 'langium';

function isInsideForLoop(node: AstNode): boolean {
  let current = node.$container;
  while (current) {
    if (isForStatement(current)) {
      return true;
    }
    current = current.$container;
  }
  return false;
}
```

### Design Decisions

1. **Grammar Location**: Add statements to `OperationStatement` alternatives (alongside `IfStatement`, `ForStatement`)
2. **Validation Approach**: AST traversal to find containing `ForStatement` (simple, no compiler infrastructure needed)
3. **Error Messages**: Match existing Langium validator style (clear, actionable)
4. **Test Strategy**: Follow existing test organization (parsing → validation → transformation → integration)

**Research Complete**: All patterns validated. No unknowns remaining.

---

## Phase 1: Design Artifacts

### Data Model

**AST Nodes** (generated by Langium):

```typescript
// Generated in packages/language/src/generated/ast.ts

export interface BreakStatement extends AstNode {
  $type: 'BreakStatement';
  // No properties - just the keyword
}

export interface ContinueStatement extends AstNode {
  $type: 'ContinueStatement';
  // No properties - just the keyword
}
```

**Transformer Output** (IR):

```typescript
// Break statement transforms to:
{
  systemName: 'breakForEach',
  operationData: {}
}

// Continue statement transforms to:
{
  systemName: 'continueForEach',
  operationData: {}
}
```

No new types needed - these map directly to existing Eligius operations.

### API Contracts

**Grammar Contract** (`eligian.langium`):

```langium
/**
 * Operation Statement - Any statement that can appear in an action or timeline body
 */
OperationStatement:
    IfStatement
    | ForStatement
    | VariableDeclaration
    | BreakStatement      // ← NEW
    | ContinueStatement   // ← NEW
    | OperationCall;

/**
 * Break Statement - Exit current loop immediately
 *
 * Compiles to: breakForEach() operation
 *
 * Examples:
 *   for (item in items) {
 *     if (@@currentItem.invalid) {
 *       break  // Exit loop
 *     }
 *   }
 *
 * Validation: Must appear inside a ForStatement
 */
BreakStatement:
    'break';

/**
 * Continue Statement - Skip to next loop iteration
 *
 * Compiles to: continueForEach() operation
 *
 * Examples:
 *   for (item in items) {
 *     if (@@currentItem.skip) {
 *       continue  // Skip this iteration
 *     }
 *   }
 *
 * Validation: Must appear inside a ForStatement
 */
ContinueStatement:
    'continue';
```

**Transformer Contract** (`ast-transformer.ts`):

```typescript
/**
 * Transform a BreakStatement to breakForEach operation.
 *
 * @param stmt - BreakStatement AST node
 * @param scope - Current scope context (loop variables, etc.)
 * @returns Effect producing array with single breakForEach operation
 */
export function* transformBreakStatement(
  stmt: BreakStatement,
  scope?: ScopeContext
): Effect.Effect<OperationConfigIR[], TransformError>;

/**
 * Transform a ContinueStatement to continueForEach operation.
 *
 * @param stmt - ContinueStatement AST node
 * @param scope - Current scope context (loop variables, etc.)
 * @returns Effect producing array with single continueForEach operation
 */
export function* transformContinueStatement(
  stmt: ContinueStatement,
  scope?: ScopeContext
): Effect.Effect<OperationConfigIR[], TransformError>;
```

**Validator Contract** (`eligian-validator.ts`):

```typescript
/**
 * Validate that break statement appears inside a loop.
 *
 * Error if:
 * - Statement is not inside a ForStatement
 *
 * @param stmt - BreakStatement to validate
 * @param accept - Langium validation acceptor
 */
checkBreakStatement(stmt: BreakStatement, accept: ValidationAcceptor): void;

/**
 * Validate that continue statement appears inside a loop.
 *
 * Error if:
 * - Statement is not inside a ForStatement
 *
 * @param stmt - ContinueStatement to validate
 * @param accept - Langium validation acceptor
 */
checkContinueStatement(stmt: ContinueStatement, accept: ValidationAcceptor): void;
```

### Quickstart Examples

**Example 1: Skip invalid items**

```eligian
// DSL with continue
for (item in items) {
  if (@@currentItem.invalid) {
    continue  // Skip this iteration
  }

  processItem(@@currentItem)
}
```

**Example 2: Early exit on error**

```eligian
// DSL with break
for (slide in slides) {
  processSlide(@@currentItem)

  if ($operationdata.errorOccurred) {
    break  // Exit loop immediately
  }
}
```

**Example 3: Mixed with explicit operations (backwards compatibility)**

```eligian
for (item in items) {
  // Old style - still works
  if (condition1) {
    continueForEach()
  }

  // New style - also works
  if (condition2) {
    continue
  }

  processItem(@@currentItem)
}
```

---

## Phase 2: Implementation Tasks

**Note**: Detailed task breakdown will be generated by `/speckit.tasks` command.

### High-Level Task Groups

1. **Grammar Extension**
   - Add `BreakStatement` and `ContinueStatement` to grammar
   - Regenerate Langium artifacts (`npm run langium:generate`)
   - Add parsing tests

2. **AST Transformer**
   - Implement `transformBreakStatement`
   - Implement `transformContinueStatement`
   - Update `transformOperationStatement` dispatcher
   - Add transformer tests

3. **Validation**
   - Implement `checkBreakStatement` validator
   - Implement `checkContinueStatement` validator
   - Add helper function `isInsideForLoop`
   - Add validation tests

4. **Integration Testing**
   - Add pipeline integration tests
   - Add example files demonstrating usage
   - Verify VS Code integration (red squiggles for errors)

5. **Documentation & Cleanup**
   - Update CLAUDE.md with new syntax
   - Add grammar documentation comments
   - Run Biome checks (`npm run check`)
   - Verify all tests pass

---

## Testing Strategy

### Unit Tests

**Parsing Tests** (`packages/language/src/__tests__/parsing.spec.ts`):
```typescript
describe('Break and Continue Statements', () => {
  test('should parse break statement', async () => {
    const code = 'for (item in items) { break }';
    const result = await parseHelper.parse(code);
    expect(result.parserErrors).toHaveLength(0);
    const breakStmt = result.value.actions[0].operations[0];
    expect(isBreakStatement(breakStmt)).toBe(true);
  });

  test('should parse continue statement', async () => {
    const code = 'for (item in items) { continue }';
    const result = await parseHelper.parse(code);
    expect(result.parserErrors).toHaveLength(0);
    const continueStmt = result.value.actions[0].operations[0];
    expect(isContinueStatement(continueStmt)).toBe(true);
  });

  test('should parse multiple break/continue in loop', async () => {
    const code = `
      for (item in items) {
        if (condition1) { continue }
        if (condition2) { break }
      }
    `;
    const result = await parseHelper.parse(code);
    expect(result.parserErrors).toHaveLength(0);
  });
});
```

**Validation Tests** (`packages/language/src/__tests__/validation.spec.ts`):
```typescript
describe('Break and Continue Validation', () => {
  test('should error on break outside loop', async () => {
    const code = 'action demo [ break ]';
    const result = await parseHelper.parse(code);
    const validationErrors = await validationHelper.validate(result);
    expect(validationErrors).toContainEqual(
      expect.objectContaining({
        message: expect.stringContaining('break can only be used inside a loop'),
        severity: 'error'
      })
    );
  });

  test('should error on continue outside loop', async () => {
    const code = 'action demo [ continue ]';
    const result = await parseHelper.parse(code);
    const validationErrors = await validationHelper.validate(result);
    expect(validationErrors).toContainEqual(
      expect.objectContaining({
        message: expect.stringContaining('continue can only be used inside a loop'),
        severity: 'error'
      })
    );
  });

  test('should allow break inside loop', async () => {
    const code = 'action demo [ for (item in items) { break } ]';
    const result = await parseHelper.parse(code);
    const validationErrors = await validationHelper.validate(result);
    expect(validationErrors).toHaveLength(0);
  });

  test('should allow continue inside loop', async () => {
    const code = 'action demo [ for (item in items) { continue } ]';
    const result = await parseHelper.parse(code);
    const validationErrors = await validationHelper.validate(result);
    expect(validationErrors).toHaveLength(0);
  });

  test('should allow break in nested loop', async () => {
    const code = `
      action demo [
        for (outer in items) {
          for (inner in subitems) {
            break
          }
        }
      ]
    `;
    const result = await parseHelper.parse(code);
    const validationErrors = await validationHelper.validate(result);
    expect(validationErrors).toHaveLength(0);
  });
});
```

**Transformer Tests** (`packages/language/src/compiler/__tests__/transformer.spec.ts`):
```typescript
describe('Break and Continue Transformation', () => {
  test('should transform break to breakForEach operation', async () => {
    const code = `
      timeline "test" using raf {
        for (item in items) {
          break
        }
      }
    `;
    const program = await parseDSL(code);
    const result = await Effect.runPromise(transformAST(program));

    const operations = result.config.timelines[0].timelineActions[0].startOperations;
    const breakOp = operations.find(op => op.systemName === 'breakForEach');
    expect(breakOp).toBeDefined();
    expect(breakOp?.operationData).toEqual({});
  });

  test('should transform continue to continueForEach operation', async () => {
    const code = `
      timeline "test" using raf {
        for (item in items) {
          continue
        }
      }
    `;
    const program = await parseDSL(code);
    const result = await Effect.runPromise(transformAST(program));

    const operations = result.config.timelines[0].timelineActions[0].startOperations;
    const continueOp = operations.find(op => op.systemName === 'continueForEach');
    expect(continueOp).toBeDefined();
    expect(continueOp?.operationData).toEqual({});
  });

  test('should transform conditional break/continue', async () => {
    const code = `
      timeline "test" using raf {
        for (item in items) {
          if (@@currentItem.skip) {
            continue
          }
          if (@@currentItem.stop) {
            break
          }
          processItem(@@currentItem)
        }
      }
    `;
    const program = await parseDSL(code);
    const result = await Effect.runPromise(transformAST(program));

    const operations = result.config.timelines[0].timelineActions[0].startOperations;

    // Should have: forEach, when, continue, endWhen, when, break, endWhen, startAction, endForEach
    expect(operations.some(op => op.systemName === 'continueForEach')).toBe(true);
    expect(operations.some(op => op.systemName === 'breakForEach')).toBe(true);
  });
});
```

### Integration Tests

**Pipeline Tests** (`packages/language/src/compiler/__tests__/pipeline.spec.ts`):
```typescript
describe('Break and Continue Pipeline Integration', () => {
  test('should compile DSL with break to valid Eligius JSON', async () => {
    const code = `
      timeline "test" using raf {
        for (item in items) {
          selectElement(@@currentItem)
          if ($operationdata.done) {
            break
          }
        }
      }
    `;
    const result = await Effect.runPromise(compile(code).pipe(Effect.provide(testLayer)));

    expect(result.config.timelines[0].timelineActions).toHaveLength(1);
    const operations = result.config.timelines[0].timelineActions[0].startOperations;
    expect(operations.some(op => op.systemName === 'breakForEach')).toBe(true);
  });

  test('should compile DSL with continue to valid Eligius JSON', async () => {
    const code = `
      timeline "test" using raf {
        for (item in items) {
          if (@@currentItem.invalid) {
            continue
          }
          processItem(@@currentItem)
        }
      }
    `;
    const result = await Effect.runPromise(compile(code).pipe(Effect.provide(testLayer)));

    expect(result.config.timelines[0].timelineActions).toHaveLength(1);
    const operations = result.config.timelines[0].timelineActions[0].startOperations;
    expect(operations.some(op => op.systemName === 'continueForEach')).toBe(true);
  });
});
```

---

## Risk Assessment

### Low Risk Areas

- **Grammar Extension**: Simple terminal rules, no ambiguity
- **Transformer**: Straightforward mapping to single operation
- **Testing**: Patterns well-established from existing features

### Medium Risk Areas

- **Validation**: AST traversal for loop detection
  - **Mitigation**: Use Langium's `AstUtils` for safe traversal
  - **Testing**: Comprehensive validation tests including nested loops

### High Risk Areas

None identified.

---

## Dependencies & Prerequisites

### External Dependencies
- Langium 3.x (existing)
- Effect-ts 3.x (existing)
- Vitest 3.x (existing)

### Internal Prerequisites
- Operation registry already has `breakForEach` and `continueForEach` (✅ completed)
- Existing transformer patterns for statements (✅ available)
- Existing validation patterns (✅ available)

### Blocking Issues
None.

---

## Success Metrics

### Functional Requirements
- [x] `break` keyword parses correctly
- [x] `continue` keyword parses correctly
- [x] Transform to correct Eligius operations
- [x] Validation catches misuse (outside loops)
- [x] All existing tests pass (no regressions)

### Quality Requirements
- [x] 100% test coverage for new code
- [x] Biome checks pass (0 errors, 0 warnings)
- [x] Documentation complete (grammar comments, examples)
- [x] VS Code integration works (errors show as red squiggles)

### Performance Requirements
- [x] No measurable compilation time increase (<1ms overhead)
- [x] Grammar remains deterministic (no parse ambiguity)

---

## Rollback Plan

If critical issues arise:

1. **Grammar Issues**: Revert grammar changes, regenerate Langium artifacts
2. **Transformer Issues**: Disable transformation (return empty operations)
3. **Validation Issues**: Disable validators (allow all usage temporarily)

**Full Rollback**: Single PR can be reverted cleanly (all changes in one commit).

---

## Post-Implementation

### Follow-Up Tasks
- [ ] Monitor user feedback on syntax clarity
- [ ] Consider adding similar sugar for other control flow operations (if Eligius adds them)

### Documentation Updates
- [ ] Update CLAUDE.md with new syntax patterns
- [ ] Add to grammar documentation
- [ ] Create example files in `examples/`

### Metrics to Track
- Usage adoption (grep for `break`/`continue` vs `breakForEach()`/`continueForEach()`)
- Validation error frequency (misuse outside loops)

---

**Plan Status**: ✅ **COMPLETE** - Ready for task generation (`/speckit.tasks`)

**Estimated Effort**: 2-3 hours
- Grammar & Parsing: 30 minutes
- Transformer: 30 minutes
- Validation: 45 minutes
- Testing: 45 minutes
- Documentation & Cleanup: 30 minutes

**Complexity**: **Low** - Straightforward syntactic sugar following established patterns
