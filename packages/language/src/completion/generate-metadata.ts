/**
 * Metadata Generator for Eligian Code Completion
 *
 * This script imports operation metadata from Eligius and generates
 * TypeScript modules for use in the Eligian completion provider.
 *
 * Usage: tsx src/completion/generate-metadata.ts
 */

import { mkdirSync, writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import type { IControllerMetadata, IOperationMetadata, TPropertyMetadata } from 'eligius';
import { ctrlmetadata, eventmetadata, metadata } from 'eligius';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Output directory (same directory as this script)
const OUTPUT_DIR = join(__dirname, 'metadata');

// Ensure output directory exists (required for CI builds where directory may not exist)
mkdirSync(OUTPUT_DIR, { recursive: true });

// Filtered operations (handled by DSL keywords)
const FILTERED_OPERATIONS = new Set([
  'breakForEach',
  'continueForEach',
  'ifCondition',
  'elseCondition',
  'forEach',
]);

/**
 * Convert IOperationMetadata to our simplified structure
 */
function convertOperationMetadata(name: string, metadataFn: () => IOperationMetadata<any>) {
  const metadata = metadataFn();

  // Extract parameters from properties
  const parameters = [];
  if (metadata.properties) {
    for (const [paramName, paramMeta] of Object.entries(metadata.properties)) {
      const propMeta = paramMeta as TPropertyMetadata;

      // Handle both simple string types and complex objects
      const paramType = typeof propMeta === 'string' ? propMeta : propMeta.type;
      const required = typeof propMeta === 'object' && propMeta.required === true;
      const defaultValue =
        typeof propMeta === 'object' && 'defaultValue' in propMeta
          ? propMeta.defaultValue
          : undefined;
      const description = typeof propMeta === 'object' ? propMeta.description : undefined;

      parameters.push({
        name: paramName,
        type: paramType,
        required,
        defaultValue,
        description,
      });
    }
  }

  // Extract dependencies
  const dependencies = (metadata.dependentProperties as string[]) || [];

  // Extract outputs from outputProperties
  const outputs = [];
  if (metadata.outputProperties) {
    for (const outputName of Object.keys(metadata.outputProperties)) {
      outputs.push(outputName);
    }
  }

  return {
    name,
    description: metadata.description || '',
    category: metadata.category || 'Uncategorized',
    parameters,
    dependencies,
    outputs,
  };
}

/**
 * Convert IControllerMetadata to our simplified structure
 */
function convertControllerMetadata(name: string, metadataFn: () => IControllerMetadata<any>) {
  const metadata = metadataFn();

  // Extract parameters from properties
  const parameters = [];
  if (metadata.properties) {
    for (const [paramName, paramMeta] of Object.entries(metadata.properties)) {
      const propMeta = paramMeta as TPropertyMetadata;

      // Handle both simple string types and complex objects
      const paramType = typeof propMeta === 'string' ? propMeta : propMeta.type;
      const required = typeof propMeta === 'object' && propMeta.required === true;
      const defaultValue =
        typeof propMeta === 'object' && 'defaultValue' in propMeta
          ? propMeta.defaultValue
          : undefined;
      const description = typeof propMeta === 'object' ? propMeta.description : undefined;

      parameters.push({
        name: paramName,
        type: paramType,
        required,
        defaultValue,
        description,
      });
    }
  }

  // Extract dependencies
  const dependencies = (metadata.dependentProperties as string[]) || [];

  return {
    name,
    description: metadata.description || '',
    parameters,
    dependencies,
  };
}

/**
 * Generate operations.generated.ts
 */
function generateOperationsMetadata(metadataModule: any) {
  const operations = [];

  // Loop through all exported metadata functions
  for (const [name, metadataFn] of Object.entries(metadataModule)) {
    // Skip non-function exports (like types)
    if (typeof metadataFn !== 'function') continue;

    const metadata = convertOperationMetadata(name, metadataFn as () => IOperationMetadata<any>);
    operations.push(metadata);
  }

  // Sort alphabetically by name
  operations.sort((a, b) => a.name.localeCompare(b.name));

  // Filter out operations handled by keywords
  const filteredOperations = operations.filter(op => !FILTERED_OPERATIONS.has(op.name));

  // Generate TypeScript module
  const tsCode = `/**
 * Generated Operation Metadata for Eligian Code Completion
 *
 * DO NOT EDIT THIS FILE MANUALLY - Generated by src/completion/generate-metadata.ts
 *
 * This file contains metadata imported from the Eligius npm package.
 * Source: import { metadata } from 'eligius' (version from packages/language/package.json)
 */

export interface OperationMetadata {
  name: string;
  description: string;
  category: string;
  parameters: ParameterMetadata[];
  dependencies: string[];
  outputs: string[];
}

export interface ParameterMetadata {
  name: string;
  type: string | Array<{ value: string }>;
  required: boolean;
  defaultValue?: unknown;
  description?: string;
}

/**
 * All Eligius operations (alphabetically sorted, filtered)
 * Total operations: ${filteredOperations.length}
 */
export const OPERATIONS: OperationMetadata[] = ${JSON.stringify(filteredOperations, null, 2)};

/**
 * Operations filtered from completions (handled by DSL keywords)
 */
export const FILTERED_OPERATIONS = new Set([
  'breakForEach',
  'continueForEach',
  'ifCondition',
  'elseCondition',
  'forEach'
]);
`;

  const outputPath = join(OUTPUT_DIR, 'operations.generated.ts');
  writeFileSync(outputPath, tsCode, 'utf-8');

  return filteredOperations.length;
}

/**
 * Generate timeline-events.generated.ts from eventmetadata
 */
function generateTimelineEventsMetadata(eventmetadataModule: any) {
  const events = [];

  // Loop through all exported event metadata functions
  for (const [key, metadataFn] of Object.entries(eventmetadataModule)) {
    // Skip non-function exports
    if (typeof metadataFn !== 'function') continue;

    const eventMeta = (metadataFn as () => any)();

    // Extract event name from description (format: "Event: event-name")
    const eventName = eventMeta.description?.replace('Event: ', '') || key;

    events.push({
      name: eventName,
      description: eventMeta.description || `Event: ${key}`,
      category: eventMeta.category || 'general',
      args: eventMeta.args || [],
    });
  }

  // Sort alphabetically by name
  events.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript module
  const tsCode = `/**
 * Generated Timeline Event Metadata for Eligian Code Completion
 *
 * DO NOT EDIT THIS FILE MANUALLY - Generated by src/completion/generate-metadata.ts
 *
 * This file contains metadata imported from the Eligius npm package.
 * Source: import { eventmetadata } from 'eligius' (version from packages/language/package.json)
 */

export interface EventArgMetadata {
  name: string;
  type: string;
}

export interface TimelineEventMetadata {
  name: string;
  description: string;
  category?: string;
  args?: EventArgMetadata[];
}

/**
 * All Eligius timeline events (alphabetically sorted)
 * Total events: ${events.length}
 */
export const TIMELINE_EVENTS: TimelineEventMetadata[] = ${JSON.stringify(events, null, 2)};
`;

  const outputPath = join(OUTPUT_DIR, 'timeline-events.generated.ts');
  writeFileSync(outputPath, tsCode, 'utf-8');

  return events.length;
}

/**
 * Generate controllers.generated.ts from ctrlmetadata
 */
function generateControllersMetadata(ctrlmetadataModule: any) {
  const controllers = [];

  // Loop through all exported controller metadata functions
  for (const [name, metadataFn] of Object.entries(ctrlmetadataModule)) {
    // Skip non-function exports
    if (typeof metadataFn !== 'function') continue;

    const metadata = convertControllerMetadata(name, metadataFn as () => IControllerMetadata<any>);
    controllers.push(metadata);
  }

  // Sort alphabetically by name
  controllers.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript module
  const tsCode = `/**
 * Generated Controller Metadata for Eligian Code Completion
 *
 * DO NOT EDIT THIS FILE MANUALLY - Generated by src/completion/generate-metadata.ts
 *
 * This file contains metadata imported from the Eligius npm package.
 * Source: import { ctrlmetadata } from 'eligius' (version from packages/language/package.json)
 */

export interface ControllerMetadata {
  name: string;
  description: string;
  parameters: ControllerParameterMetadata[];
  dependencies: string[];
}

export interface ControllerParameterMetadata {
  name: string;
  type: string | Array<{ value: string }>;
  required: boolean;
  defaultValue?: unknown;
  description?: string;
}

/**
 * All Eligius controllers (alphabetically sorted)
 * Total controllers: ${controllers.length}
 */
export const CONTROLLERS: ControllerMetadata[] = ${JSON.stringify(controllers, null, 2)};

/**
 * Controller name lookup map (O(1) lookup)
 */
const CONTROLLER_MAP = new Map<string, ControllerMetadata>(
  CONTROLLERS.map(c => [c.name, c])
);

/**
 * Check if a name is a valid controller
 */
export function isController(name: string): boolean {
  return CONTROLLER_MAP.has(name);
}

/**
 * Get controller metadata by name
 */
export function getController(name: string): ControllerMetadata | undefined {
  return CONTROLLER_MAP.get(name);
}
`;

  const outputPath = join(OUTPUT_DIR, 'controllers.generated.ts');
  writeFileSync(outputPath, tsCode, 'utf-8');

  return controllers.length;
}

/**
 * Main execution
 */
function main() {
  try {
    generateOperationsMetadata(metadata);
    generateTimelineEventsMetadata(eventmetadata);
    generateControllersMetadata(ctrlmetadata);
  } catch (error) {
    console.error('‚ùå Error:', (error as Error).message);
    console.error((error as Error).stack);
    process.exit(1);
  }
}

main();
