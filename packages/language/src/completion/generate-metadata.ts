/**
 * Metadata Generator for Eligian Code Completion
 *
 * This script imports operation metadata from Eligius and generates
 * TypeScript modules for use in the Eligian completion provider.
 *
 * Usage: tsx src/completion/generate-metadata.ts
 */

import { writeFileSync } from 'node:fs';
import { dirname, join } from 'node:path';
import { fileURLToPath } from 'node:url';
import { metadata, TimelineEventNames } from 'eligius';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Output directory (same directory as this script)
const OUTPUT_DIR = join(__dirname, 'metadata');

// Filtered operations (handled by DSL keywords)
const FILTERED_OPERATIONS = new Set([
  'breakForEach',
  'continueForEach',
  'ifCondition',
  'elseCondition',
  'forEach',
]);

/**
 * Convert IOperationMetadata to our simplified structure
 */
function convertMetadata(name: string, metadataFn: () => any) {
  const metadata = metadataFn(); // Call the function to get the metadata object

  // Extract parameters from properties
  const parameters = [];
  if (metadata.properties) {
    for (const [paramName, paramMeta] of Object.entries(metadata.properties)) {
      // Handle both simple string types and complex objects
      const paramType = typeof paramMeta === 'string' ? paramMeta : (paramMeta as any).type;
      const required = typeof paramMeta === 'object' && (paramMeta as any).required === true;
      const defaultValue =
        typeof paramMeta === 'object' ? (paramMeta as any).defaultValue : undefined;
      const description =
        typeof paramMeta === 'object' ? (paramMeta as any).description : undefined;

      parameters.push({
        name: paramName,
        type: paramType,
        required,
        defaultValue,
        description,
      });
    }
  }

  // Extract dependencies
  const dependencies = metadata.dependentProperties || [];

  // Extract outputs from outputProperties
  const outputs = [];
  if (metadata.outputProperties) {
    for (const outputName of Object.keys(metadata.outputProperties)) {
      outputs.push(outputName);
    }
  }

  return {
    name,
    description: metadata.description || '',
    parameters,
    dependencies,
    outputs,
  };
}

/**
 * Generate operations.generated.ts
 */
function generateOperationsMetadata(metadataModule: any) {
  const operations = [];

  // Loop through all exported metadata functions
  for (const [name, metadataFn] of Object.entries(metadataModule)) {
    // Skip non-function exports (like types)
    if (typeof metadataFn !== 'function') continue;

    const metadata = convertMetadata(name, metadataFn as () => any);
    operations.push(metadata);
  }

  // Sort alphabetically by name
  operations.sort((a, b) => a.name.localeCompare(b.name));

  // Filter out operations handled by keywords
  const filteredOperations = operations.filter(op => !FILTERED_OPERATIONS.has(op.name));

  // Generate TypeScript module
  const tsCode = `/**
 * Generated Operation Metadata for Eligian Code Completion
 *
 * DO NOT EDIT THIS FILE MANUALLY - Generated by src/completion/generate-metadata.ts
 *
 * This file contains metadata imported from the Eligius npm package.
 * Source: import { metadata } from 'eligius' (version from packages/language/package.json)
 */

export interface OperationMetadata {
  name: string;
  description: string;
  parameters: ParameterMetadata[];
  dependencies: string[];
  outputs: string[];
}

export interface ParameterMetadata {
  name: string;
  type: string | Array<{ value: string }>;
  required: boolean;
  defaultValue?: unknown;
  description?: string;
}

/**
 * All Eligius operations (alphabetically sorted, filtered)
 * Total operations: ${filteredOperations.length}
 */
export const OPERATIONS: OperationMetadata[] = ${JSON.stringify(filteredOperations, null, 2)};

/**
 * Operations filtered from completions (handled by DSL keywords)
 */
export const FILTERED_OPERATIONS = new Set([
  'breakForEach',
  'continueForEach',
  'ifCondition',
  'elseCondition',
  'forEach'
]);
`;

  const outputPath = join(OUTPUT_DIR, 'operations.generated.ts');
  writeFileSync(outputPath, tsCode, 'utf-8');

  return filteredOperations.length;
}

/**
 * Generate timeline-events.generated.ts
 */
function generateTimelineEventsMetadata(TimelineEventNames: any) {
  const events = [];

  // Get all static properties from TimelineEventNames class
  const propertyNames = Object.getOwnPropertyNames(TimelineEventNames);

  for (const propName of propertyNames) {
    // Skip constructor and prototype
    if (
      propName === 'constructor' ||
      propName === 'prototype' ||
      propName === 'length' ||
      propName === 'name'
    ) {
      continue;
    }

    const eventName = TimelineEventNames[propName];

    // Determine category based on naming convention
    let category = 'general';
    if (propName.endsWith('_REQUEST')) {
      category = 'requests';
    } else if (
      [
        'DURATION',
        'TIME',
        'SEEKED',
        'COMPLETE',
        'RESTART',
        'PLAY',
        'STOP',
        'PAUSE',
        'SEEK',
        'RESIZE',
        'CURRENT_TIMELINE_CHANGE',
        'FIRST_FRAME',
      ].includes(propName)
    ) {
      category = 'announcements';
    } else if (propName.startsWith('REQUEST_')) {
      category = 'factory';
    }

    events.push({
      name: eventName,
      description: `Timeline event: ${propName}`,
      category,
    });
  }

  // Sort alphabetically by name
  events.sort((a, b) => a.name.localeCompare(b.name));

  // Generate TypeScript module
  const tsCode = `/**
 * Generated Timeline Event Metadata for Eligian Code Completion
 *
 * DO NOT EDIT THIS FILE MANUALLY - Generated by src/completion/generate-metadata.ts
 *
 * This file contains metadata imported from the Eligius npm package.
 * Source: import { TimelineEventNames } from 'eligius' (version from packages/language/package.json)
 */

export interface TimelineEventMetadata {
  name: string;
  description: string;
  category?: string;
}

/**
 * All Eligius timeline events (alphabetically sorted)
 * Total events: ${events.length}
 */
export const TIMELINE_EVENTS: TimelineEventMetadata[] = ${JSON.stringify(events, null, 2)};
`;

  const outputPath = join(OUTPUT_DIR, 'timeline-events.generated.ts');
  writeFileSync(outputPath, tsCode, 'utf-8');

  return events.length;
}

/**
 * Main execution
 */
function main() {
  try {
    generateOperationsMetadata(metadata);
    generateTimelineEventsMetadata(TimelineEventNames);
  } catch (error) {
    console.error('‚ùå Error:', (error as Error).message);
    console.error((error as Error).stack);
    process.exit(1);
  }
}

main();
